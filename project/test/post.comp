#version 460 core

// 
#extension GL_GOOGLE_include_directive : require

//
#include "lib/native.glsl"
#include "lib/raytracing.glsl"
#include "lib/random.glsl"
#include "lib/sphere.glsl"
#include "lib/fresnel.glsl"
#include "lib/pass.glsl"

//
layout (local_size_x = 32, local_size_y = 8, local_size_z = 1) in;

//
vec4 readAndNeighborColor(in uint pixelId, in uint type) {
  PixelHitInfoRef hitInfo = getPixelHitInfo(pixelId, type);
  vec4 center = hitInfo.color;
  if (center.w <= 0.f) {
    if ((pixelId + extent.x) < (extent.y * extent.x)) { PixelHitInfoRef info = getPixelHitInfo(pixelId + extent.x, type); center += info.color; };
    if ((pixelId.x%extent.x) < extent.x-1)            { PixelHitInfoRef info = getPixelHitInfo(pixelId + 1, type); center += info.color; };
    if (pixelId >= extent.x)                          { PixelHitInfoRef info = getPixelHitInfo(pixelId - extent.x, type); center += info.color; };
    if ((pixelId.x%extent.x) >= 1)                    { PixelHitInfoRef info = getPixelHitInfo(pixelId - 1, type); center += info.color; };
  };
  return center;
};

//
vec4 readAndNeighborEmission(in uint pixelId) {
  vec4 center = pixelData.pixels[pixelId].surface.emission;
  if (center.w <= 0.f) {
    if ((pixelId + extent.x) < (extent.y * extent.x)) { center += pixelData.pixels[pixelId + extent.x].surface.emission; };
    if ((pixelId.x%extent.x) < extent.x-1)            { center += pixelData.pixels[pixelId + 1].surface.emission; };
    if (pixelId >= extent.x)                          { center += pixelData.pixels[pixelId - extent.x].surface.emission; };
    if ((pixelId.x%extent.x) >= 1)                    { center += pixelData.pixels[pixelId - 1].surface.emission; };
  };
  return center;
};

//
vec4 readAndNeighborSurfaceDiffuse(in uint pixelId) {
  vec4 center = pixelData.pixels[pixelId].surface.diffuse;
  if (center.w <= 0.f) {
    if ((pixelId + extent.x) < (extent.y * extent.x)) { center += pixelData.pixels[pixelId + extent.x].surface.diffuse; };
    if ((pixelId.x%extent.x) < extent.x-1)            { center += pixelData.pixels[pixelId + 1].surface.diffuse; };
    if (pixelId >= extent.x)                          { center += pixelData.pixels[pixelId - extent.x].surface.diffuse; };
    if ((pixelId.x%extent.x) >= 1)                    { center += pixelData.pixels[pixelId - 1].surface.diffuse; };
  };
  return center;
};

// 
void main() {
  const uvec2 gcoord = gl_GlobalInvocationID.xy;
  const vec2 tCoord = vec2(gcoord)/vec2(extent);
  const uint pixelId = gcoord.x + extent.x * gcoord.y;

  // 
  const vec4 resultRefl = readAndNeighborColor(pixelId, 0);
  const vec4 resultTransp = readAndNeighborColor(pixelId, 1);
  const vec4 resultColor = readAndNeighborColor(pixelId, 2);
  const vec4 resultEmission = readAndNeighborEmission(pixelId);
  const vec4 resultDiffuse = readAndNeighborSurfaceDiffuse(pixelId);

  // 
  const vec4 finalColor = vec4(
    max((max(resultTransp.xyz, 0.f.xxx) / max(resultTransp.w, 1.f)), 0.f.xxx) + 
    max(trueMultColor(max(resultColor.xyz, 0.f.xxx) / max(resultColor.w, 1.f), (max(resultDiffuse.xyz, 0.f.xxx) / max(resultDiffuse.w, 1.f))), 0.f.xxx) + 
    max((max(resultEmission.xyz, 0.f.xxx) / max(resultEmission.w, 1.f)), 0.f.xxx) + 
    max((max(resultRefl.xyz, 0.f.xxx) / max(resultRefl.w, 1.f)), 0.f.xxx)
  , 1.f);

  // for debug only
  //pixelData.pixels[pixelId].reflection.accum = TYPE(0u);
  //pixelData.pixels[pixelId].diffuse.accum = TYPE(0u);
  //pixelData.pixels[pixelId].transparency.accum = TYPE(0u);

  // final color
  imageStore(images[swapchain.image], ivec2(gcoord.x, extent.y-1-gcoord.y), fromLinear(finalColor));
};
