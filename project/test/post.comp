#version 460 core

// 
#extension GL_GOOGLE_include_directive : require

//
#include "lib/native.glsl"
#include "lib/raytracing.glsl"
#include "lib/random.glsl"
#include "lib/sphere.glsl"
#include "lib/fresnel.glsl"
#include "lib/pass.glsl"

//
layout (local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

//
vec4 readAndNeighborColor(in uint pixelId, in uint type) {
  PixelHitInfoRef hitInfo = getPixelHitInfo(pixelId, type);
  vec4 center = hitInfo.color;
  if (center.w <= 0.f && (pixelId + extent.x) < (extent.y * extent.x) && ((pixelId.x%extent.x) < extent.x-1)) { 
    PixelHitInfoRef hitInfoX1 = getPixelHitInfo(pixelId + extent.x, type);
    PixelHitInfoRef hitInfoY1 = getPixelHitInfo(pixelId + 1, type);
    center = hitInfoX1.color + hitInfoY1.color; 
  };
  return center;
};

//
vec4 readAndNeighborReflectDir(in uint pixelId) {
  vec4 center = pixelData.pixels[pixelId].reflection.direction;
  if (center.w <= 0.f && (pixelId + extent.x) < (extent.y * extent.x) && ((pixelId.x%extent.x) < extent.x-1)) { center = (pixelData.pixels[pixelId + extent.x].reflection.direction + pixelData.pixels[pixelId + 1].reflection.direction)/2.f; center.xyz = normalize(center.xyz); };
  return center;
};

//
vec4 readAndNeighborEmission(in uint pixelId) {
  vec4 center = pixelData.pixels[pixelId].surface.emission;
  if (center.w <= 0.f && (pixelId + extent.x) < (extent.y * extent.x) && ((pixelId.x%extent.x) < extent.x-1)) { center = pixelData.pixels[pixelId + extent.x].surface.emission + pixelData.pixels[pixelId + 1].surface.emission; };
  return center;
};

//
vec4 readAndNeighborSurfaceDiffuse(in uint pixelId) {
  vec4 center = pixelData.pixels[pixelId].surface.diffuse;
  if (center.w <= 0.f && (pixelId + extent.x) < (extent.y * extent.x) && ((pixelId.x%extent.x) < extent.x-1)) { center = pixelData.pixels[pixelId + extent.x].surface.diffuse + pixelData.pixels[pixelId + 1].surface.diffuse; };
  return center;
};

// 
void main() {
  const uvec2 gcoord = gl_GlobalInvocationID.xy;
  const vec2 tCoord = vec2(gcoord)/vec2(extent);
  const uint pixelId = gcoord.x + extent.x * gcoord.y;

  // 
  const vec4 resultRefl = readAndNeighborColor(pixelId, 0);
  const vec4 resultTransp = readAndNeighborColor(pixelId, 1);
  const vec4 resultColor = readAndNeighborColor(pixelId, 2);
  const vec4 resultEmission = readAndNeighborEmission(pixelId);
  const vec4 resultDiffuse = readAndNeighborSurfaceDiffuse(pixelId);

  // 
  const vec4 finalColor = vec4(
    (max(resultTransp.xyz, 0.f.xxx) / max(resultTransp.w, 1.f)) + 
    trueMultColor(max(resultColor.xyz, 0.f.xxx) / max(resultColor.w, 1.f), (max(resultDiffuse.xyz, 0.f.xxx) / max(resultDiffuse.w, 1.f))) + 
    (max(resultEmission.xyz, 0.f.xxx) / max(resultEmission.w, 1.f)) + 
    (max(resultRefl.xyz, 0.f.xxx) / max(resultRefl.w, 1.f))
  , 1.f);

  // for debug only
  //pixelData.pixels[pixelId].reflection.accum = TYPE(0u);
  //pixelData.pixels[pixelId].diffuse.accum = TYPE(0u);
  //pixelData.pixels[pixelId].transparency.accum = TYPE(0u);

  // final color
  imageStore(images[swapchain.image], ivec2(gcoord.x, extent.y-1-gcoord.y), fromLinear(finalColor));
};
