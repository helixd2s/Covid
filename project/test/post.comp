#version 460 core

// 
#extension GL_GOOGLE_include_directive : require

//
#include "lib/native.glsl"
#include "lib/fresnel.glsl"
#include "lib/random.glsl"
#include "lib/sphere.glsl"

//
layout (local_size_x = 32, local_size_y = 8, local_size_z = 1) in;

//
vec4 readAndNeighborColor(in uint pixelId, in uint type) {
  PixelSurfaceInfoRef surf = getPixelSurface(pixelId);
  vec4 center = surf.color[type];
  if (center.w <= 0.f) {
    center = vec4(0.f);
    if ((pixelId + extent.x) < (extent.y * extent.x)) { PixelSurfaceInfoRef surf = getPixelSurface(pixelId + extent.x); center += surf.color[type]; };
    if ((pixelId.x%extent.x) < extent.x-1)            { PixelSurfaceInfoRef surf = getPixelSurface(pixelId + 1); center += surf.color[type]; };
    if (pixelId >= extent.x)                          { PixelSurfaceInfoRef surf = getPixelSurface(pixelId - extent.x); center += surf.color[type]; };
    if ((pixelId.x%extent.x) >= 1)                    { PixelSurfaceInfoRef surf = getPixelSurface(pixelId - 1); center += surf.color[type]; };
  };
  return center;
};

//
vec4 readAndNeighborTex(in uint pixelId, in uint tex) {
  PixelSurfaceInfoRef surf = getPixelSurface(pixelId);
  vec4 center = surf.tex[tex];
  if (center.w <= 0.f) {
    center = vec4(0.f);
    if ((pixelId + extent.x) < (extent.y * extent.x)) { PixelSurfaceInfoRef surf = getPixelSurface(pixelId + extent.x); center += surf.tex[tex]; };
    if ((pixelId.x%extent.x) < extent.x-1)            { PixelSurfaceInfoRef surf = getPixelSurface(pixelId + 1); center += surf.tex[tex]; };
    if (pixelId >= extent.x)                          { PixelSurfaceInfoRef surf = getPixelSurface(pixelId - extent.x); center += surf.tex[tex]; };
    if ((pixelId.x%extent.x) >= 1)                    { PixelSurfaceInfoRef surf = getPixelSurface(pixelId - 1); center += surf.tex[tex]; };
  };
  return center;
};

// 
void main() {
  const uvec2 gcoord = gl_GlobalInvocationID.xy;
  const vec2 tCoord = vec2(gcoord)/vec2(extent);
  const uint pixelId = gcoord.x + extent.x * gcoord.y;

  // 
  const vec4 resultRefl = readAndNeighborColor(pixelId, 0);
  const vec4 resultTransp = readAndNeighborColor(pixelId, 1);
  const vec4 resultColor = readAndNeighborColor(pixelId, 2);
  const vec4 resultEmission = readAndNeighborTex(pixelId, EMISSION_TEX);
  const vec4 resultDiffuse = readAndNeighborTex(pixelId, DIFFUSE_TEX);

  // 
  const vec4 finalColor = vec4(clampCol(
    clampCol(resultTransp) + 
    clampCol(trueMultColor(clampCol(resultColor), clampCol(resultDiffuse))) + 
    clampCol(resultEmission) + 
    clampCol(resultRefl)
  ).xyz, 1.f);

  // for debug only
  //pixelData.pixels[pixelId].reflection.accum = TYPE(0u);
  //pixelData.pixels[pixelId].diffuse.accum = TYPE(0u);
  //pixelData.pixels[pixelId].transparency.accum = TYPE(0u);

  // final color
  imageStore(images[swapchain.image], ivec2(gcoord.x, extent.y-1-gcoord.y), fromLinear(finalColor));
};
