#version 460 core

// 
#extension GL_GOOGLE_include_directive : require

//
#include "lib/native.glsl"
#include "lib/raytracing.glsl"
#include "lib/random.glsl"
#include "lib/sphere.glsl"
#include "lib/fresnel.glsl"
#include "lib/pass.glsl"

//
layout (local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

//
vec3 proj_point_in_plane(in vec3 p, in vec3 v0, in vec3 n, out float d) {
  d = dot(n, p - v0);
  return p - (n * d);
};

//
vec3 find_reflection_incident_point(in vec3 p0, in vec3 p1, in vec3 v0, in vec3 n) {
  float d0 = 0;
  float d1 = 0;
  vec3 proj_p0 = proj_point_in_plane(p0, v0, n, d0);
  vec3 proj_p1 = proj_point_in_plane(p1, v0, n, d1);

  if(d1 < d0)
    return (proj_p0 - proj_p1) * d1/(d0+d1) + proj_p1;
  else
    return (proj_p1 - proj_p0) * d0/(d0+d1) + proj_p0;
};

//
vec3 fetchSrcPos(in ivec2 srcInt) {
  PixelSurfaceInfoRef surf = getPixelSurface(uint(srcInt.x + srcInt.y * extent.x));
  return surf.origin.xyz;
};

//
vec3 texSrcPos(in vec2 srcScreen) {
  //return fetchSrcPos(ivec2(ceil(fract(srcScreen) * (extent) - 0.5f)));
  //return fetchSrcPos(ivec2(round(fract(srcScreen) * (extent) - 0.49999f)));
  return fetchSrcPos(ivec2(round(clamp(srcScreen, 0.f, 0.99999f) * (extent) - 0.49999f)));
};

//
vec3 linearSrcPos(in vec2 txy) {
  const vec2 txs = extent;
  const vec2 txd = 1.f/extent;
  const vec2 ttf = fract(txy*txs.xy-0.5f);
  const vec2 px = vec2(1.f-ttf.x,ttf.x), py = vec2(1.f-ttf.y,ttf.y);
  const mat2x2 i2 = outerProduct(px,py);
  const vec2 pix = txy-(ttf*txd)+0.0001f;
  const mat4x3 texels = mat4x3(
    texSrcPos(pix+vec2(0.f  ,0.f)), texSrcPos(pix+vec2(txd.x,0.f  )),
    texSrcPos(pix+vec2(txd.y,0.f)), texSrcPos(pix+vec2(txd.x,txd.y))
  );
  return texels*vec4(i2[0],i2[1]);
};



//
//void reproject3D(in PixelSurfaceInfo surface, in PixelHitInfo data, in uint pixelId, in vec3 srcRayDir, in int type) {
void reproject3D(in uint pixelId, in vec3 srcRayDir, in int type) {
  PixelSurfaceInfoRef surface = getPixelSurface(pixelId);
  PixelHitInfoRef data = getPixelHitInfo(pixelId, type);

  //
  const vec3 srcHitPos = data.direction.xyz + data.direction.w * srcRayDir;
  const vec3 srcPos = data.direction.xyz;
  const vec3 srcNormal = surface.normal.xyz;

  //
  const vec3 dstPos = vec4(vec4(srcPos.xyz, 1.f) * inverse(getPreviousInstanceTransform(instancedData.opaqueAddressInfo, surface.indices.x)), 1.f) * getInstanceTransform(instancedData.opaqueAddressInfo, surface.indices.x);
  const vec3 dstHitPos = vec4(vec4(srcHitPos.xyz, 1.f) * inverse(getPreviousInstanceTransform(instancedData.opaqueAddressInfo, data.indices.x)), 1.f) * getInstanceTransform(instancedData.opaqueAddressInfo, data.indices.x);
  const vec3 dstNormal = normalize(srcNormal.xyz * toNormalMat(getPreviousInstanceTransform(instancedData.opaqueAddressInfo, surface.indices.x)) * toNormalMat(inverse(getInstanceTransform(instancedData.opaqueAddressInfo, surface.indices.x))));
  const vec3 dstRayDir = normalize(srcRayDir.xyz * toNormalMat(getPreviousInstanceTransform(instancedData.opaqueAddressInfo, surface.indices.x)) * toNormalMat(inverse(getInstanceTransform(instancedData.opaqueAddressInfo, surface.indices.x))));

  //
  const vec3 srcHitFoundIntersection = find_reflection_incident_point( dstPos.xyz, srcHitPos.xyz, srcPos.xyz, normalize(srcNormal.xyz));
  //const vec3 srcHitFoundIntersection = find_reflection_incident_point( srcPos.xyz, srcHitPos.xyz, dstPos.xyz, normalize(srcNormal.xyz));
  //const vec3 dstHitFoundIntersection = vec4(vec4(srcHitFoundIntersection.xyz, 1.f) * inverse(getPreviousInstanceTransform(instancedData.opaqueAddressInfo, data.indices.x)), 1.f) * getInstanceTransform(instancedData.opaqueAddressInfo, data.indices.x);
  const vec3 dstHitFoundIntersection = dstPos;

  //
  const vec4 srcHitPersp = vec4(vec4(srcHitFoundIntersection, 1.f) * constants.previousLookAt, 1.f) * constants.perspective;
  const vec2 srcScreen = (srcHitPersp.xy/srcHitPersp.w * 0.5f + 0.5f);
  const ivec2 srcInt = ivec2(round(srcScreen * vec2(extent) - 0.49999f));
  const uint srcId = uint(srcInt.x + srcInt.y * extent.x);
  const bool srcValid = srcInt.x < extent.x && srcInt.y < extent.y;

  // 
  const vec4 dstHitPersp = vec4(vec4(dstPos, 1.f) * constants.lookAt, 1.f) * constants.perspective;
  const vec2 dstScreen = (dstHitPersp.xy/dstHitPersp.w * 0.5f + 0.5f);
  const ivec2 dstInt = ivec2(round(dstScreen * vec2(extent) - 0.49999f));
  const uint dstId = uint(dstInt.x + dstInt.y * extent.x);
  const bool dstValid = dstInt.x < extent.x && dstInt.y < extent.y;

  // 
  if (srcValid && dstValid) {
    //
    PixelSurfaceInfoRef SURF_SRC = getPixelSurface(srcId), SURF_DST = getPixelSurface(dstId);
    PixelHitInfoRef HIT_SRC = getPixelHitInfo(srcId, type), HIT_DST = getPixelHitInfo(dstId, type);

    // TODO: screen space coordinates
    const bool dstValidDist = distance(texture(sampler2D(textures[framebufferAttachments[2]], samplers[0u]), dstScreen.xy, 0).xyz, dstPos.xyz) < 0.01f;
    const bool srcValidDist = true;//distance(linearSrcPos(srcScreen), srcHitFoundIntersection.xyz) < 0.01f; // TODO: complex linear interpolation

    //
    if ( HIT_SRC.color.w > 0.f && dstValidDist && (HIT_SRC.direction.w < 10000.f && srcValidDist || HIT_DST.color.w <= 0.f) ) {
      accumulate(HIT_DST, cvtRgb16Float(HIT_SRC.color));
      HIT_DST.actualDirection = vec4(dstPos, distance(dstHitPos, dstPos));
    };
  };

};

//
void reprojectDiffuse(in uint srcId, in vec3 srcRayDir) {
  PixelSurfaceInfoRef surface = getPixelSurface(srcId);
  PixelHitInfoRef data = getPixelHitInfo(srcId, 2);

  //
  const vec3 srcPos = surface.origin.xyz;
  const vec3 srcNormal = surface.normal.xyz;

  //
  const vec3 dstPos = vec4(vec4(srcPos.xyz, 1.f) * inverse(getPreviousInstanceTransform(instancedData.opaqueAddressInfo, surface.indices.x)), 1.f) * getInstanceTransform(instancedData.opaqueAddressInfo, surface.indices.x);
  const vec3 dstNormal = normalize(srcNormal.xyz * toNormalMat(getPreviousInstanceTransform(instancedData.opaqueAddressInfo, surface.indices.x)) * toNormalMat(inverse(getInstanceTransform(instancedData.opaqueAddressInfo, surface.indices.x))));
  const vec3 dstRayDir = normalize(srcRayDir.xyz * toNormalMat(getPreviousInstanceTransform(instancedData.opaqueAddressInfo, surface.indices.x)) * toNormalMat(inverse(getInstanceTransform(instancedData.opaqueAddressInfo, surface.indices.x))));

  //
  const vec4 dstPerspPos = vec4(vec4(dstPos.xyz, 1.f) * constants.lookAt, 1.f) * constants.perspective;
  const vec2 dstScreen = (dstPerspPos.xy/dstPerspPos.w) * 0.5f + 0.5f;
  const vec4 dstSamplePos = vec4(texture(sampler2D(textures[framebufferAttachments[2]], samplers[0u]), dstScreen, 0).xyz, 1.f);
  const ivec2 dstScreenPos = ivec2(round(dstScreen * vec2(extent) - 0.49999f));

  //
  if (dstScreenPos.x < extent.x && dstScreenPos.y < extent.y) {
    const uint dstId = uint(dstScreenPos.x + dstScreenPos.y * extent.x);
    PixelSurfaceInfoRef dstSurface = getPixelSurface(dstId);
    PixelHitInfoRef dstData = getPixelHitInfo(dstId, 2);
    if (data.color.w > 0.f && (distance( dstSamplePos.xyz, dstPos.xyz) < 0.001f || pixelData.pixels[dstId].diffuse.color.w <= 0.f)) {
      accumulate(dstData, cvtRgb16Float(data.color));
      accumulateDiffuseTex(dstSurface, cvtRgb16Float(surface.diffuse));
      accumulateEmissiveTex(dstSurface, cvtRgb16Float(surface.emission));
      pixelData.pixels[dstId].surface.actualOrigin.xyz = dstPos.xyz;
      pixelData.pixels[dstId].surface.actualNormal.xyz = dstNormal.xyz;
    };
  };
}

// 
void main() {
  const uvec2 gcoord = gl_GlobalInvocationID.xy;
  const vec2 tCoord = vec2(gcoord)/vec2(extent);
  const uint pixelId = gcoord.x + extent.x * gcoord.y;

  //
  const vec3 srcRayBegin = divW(vec4(vec3(tCoord, 0.f) * 2.f - 1.f, 1.f) * constants.perspectiveInverse) * constants.previousLookAtInverse;//fullTransform(instanceInfo, attrib.data[VERTEX_VERTICES], intersection.geometryId);
  const vec3 srcRayEnd = divW(vec4(vec3(tCoord, 1.f) * 2.f - 1.f, 1.f) * constants.perspectiveInverse) * constants.previousLookAtInverse;
  const vec3 srcRayDir = normalize(srcRayEnd.xyz - srcRayBegin.xyz);

  //
  reprojectDiffuse(pixelId, srcRayDir);
  reproject3D(pixelId, srcRayDir, 0);
  reproject3D(pixelId, srcRayDir, 1);
};
