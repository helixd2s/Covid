#version 460 core

// 
#extension GL_GOOGLE_include_directive : require

//
#include "lib/native.glsl"
#include "lib/fresnel.glsl"
#include "lib/random.glsl"
#include "lib/sphere.glsl"
#include "lib/pupet.glsl"

//
layout (local_size_x = 32, local_size_y = 8, local_size_z = 1) in;

//
vec3 proj_point_in_plane(in vec3 p, in vec3 v0, in vec3 n, out float d) { return p - ((d = dot(n, p - v0)) * n); };
vec3 find_reflection_incident_point(in vec3 p0, in vec3 p1, in vec3 v0, in vec3 n) {
  float d0 = 0; vec3 proj_p0 = proj_point_in_plane(p0, v0, n, d0);
  float d1 = 0; vec3 proj_p1 = proj_point_in_plane(p1, v0, n, d1);
  if(d1 < d0) { return (proj_p0 - proj_p1) * d1/(d0+d1) + proj_p1; }
         else { return (proj_p1 - proj_p0) * d0/(d0+d1) + proj_p0; };
};



//
vec4 fetchSrcPosRaw(in ivec2 srcInt) {
  PixelSurfaceInfoRef surf = getPixelSurface(uint(srcInt.x + srcInt.y * extent.x));
  return vec4(surf.origin.xyz, 1.f);
};

//
vec4 fetchSrcPos(in ivec2 srcInt) {
  PixelSurfaceInfoRef surf = getPixelSurface(uint(srcInt.x + srcInt.y * extent.x));
  vec4 center = vec4(surf.origin.xyz, 1.f);
  if (all(lessThanEqual(abs(center.xyz),0.f.xxx))) {
    center = (
      fetchSrcPosRaw(clamp(srcInt+ivec2(0,1),int(0).xx,ivec2(extent)-1)) + 
      fetchSrcPosRaw(clamp(srcInt+ivec2(1,0),int(0).xx,ivec2(extent)-1)) + 
      fetchSrcPosRaw(clamp(srcInt+ivec2(0,-1),int(0).xx,ivec2(extent)-1)) + 
      fetchSrcPosRaw(clamp(srcInt+ivec2(-1,0),int(0).xx,ivec2(extent)-1))
    ) / 4.f;
  };
  return divW(vec4(center * constants.previousLookAt, 1.f) * constants.perspective);
};

//
vec3 texSrcPos(in vec2 srcScreen) {
  return fetchSrcPos(clamp(ivec2(srcScreen*extent),int(0).xx,ivec2(extent)-1)).xyz;
};

//
vec3 linearSrcPos(in vec2 txy) {
  const vec2 txs = extent;
  const vec2 txd = 1.f/txs;
  const vec2 ttf = fract(txy*txs.xy - 0.49999f);
  const vec2 px = vec2(1.f-ttf.x,ttf.x), py = vec2(1.f-ttf.y,ttf.y);
  const mat2x2 i2 = outerProduct(px,py);
  const vec2 pix = clamp(txy-0.49999f*txd,0.f.xx,0.99999f.xx);
  const mat4x3 texels = mat4x3(
    texSrcPos(pix+vec2(0.f,  0.f)), texSrcPos(pix+vec2(txd.x,  0.f)),
    texSrcPos(pix+vec2(0.f,txd.y)), texSrcPos(pix+vec2(txd.x,txd.y))
  );
  return texels*vec4(i2[0],i2[1]);
};


//
//void reproject3D(in PixelSurfaceInfo surface, in PixelHitInfo data, in uint pixelId, in vec3 srcRayDir, in int type) {
void reproject3D(in uint pixelId, in vec3 srcRayDir, in int type) {
  PixelSurfaceInfoRef surface = getPixelSurface(pixelId);
  PixelHitInfoRef data = getNewHit(pixelId, type);

  //
  if (data.origin.x != 0.f || data.origin.y != 0.f || data.origin.z != 0.f) {
    // 
    const vec3 srcHitPos = data.origin.xyz + data.origin.w * srcRayDir;
    const vec3 srcPos = data.origin.xyz;
    const vec3 srcNormal = surface.normal.xyz;

    // 
    const vec3 dstPos = vec4(vec4(srcPos.xyz, 1.f) 
      * inverse(getPreviousInstanceTransform(instancedData, surface.indices.x)), 1.f) 
      * getInstanceTransform(instancedData, surface.indices.x);
    const vec3 dstHitPos = vec4(vec4(srcHitPos.xyz, 1.f) 
      * inverse(getPreviousInstanceTransform(instancedData, data.indices.x)), 1.f) 
      * getInstanceTransform(instancedData, data.indices.x);
    const vec3 dstNormal = normalize(srcNormal.xyz 
      * toNormalMat(getPreviousInstanceTransform(instancedData, surface.indices.x)) 
      * toNormalMat(inverse(getInstanceTransform(instancedData, surface.indices.x)))
    );
    const vec3 dstRayDir = normalize(srcRayDir.xyz 
      * toNormalMat(getPreviousInstanceTransform(instancedData, surface.indices.x)) 
      * toNormalMat(inverse(getInstanceTransform(instancedData, surface.indices.x)))
    );

    // 
    const vec3 dstHitFoundIntersection = type == 2 ? dstPos : (type == 1 ? dstHitPos : vec4(
      find_reflection_incident_point( 
        vec4(dstPos.xyz, 1.f) * constants.lookAt, 
        vec4(srcHitPos.xyz, 1.f) * constants.previousLookAt, 
        vec4(srcPos.xyz, 1.f) * constants.previousLookAt, 
        normalize(srcNormal.xyz)
      ), 1.f) * constants.lookAtInverse);

    // 
    const vec3 srcHitFoundIntersection = type == 2 ? srcPos : (type == 1 ? srcHitPos : vec4(vec4(dstHitFoundIntersection, 1.f)
      * inverse(getInstanceTransform(instancedData, type == 1 ? data.indices.x : surface.indices.x)), 1.f) 
      * getPreviousInstanceTransform(instancedData, type == 1 ? data.indices.x : surface.indices.x));

    // 
    const vec4 srcHitPersp = vec4(vec4(srcHitFoundIntersection, 1.f) * constants.previousLookAt, 1.f) * constants.perspective;
    const vec2 srcScreen = (srcHitPersp.xy/srcHitPersp.w * 0.5f + 0.5f);
    const ivec2 srcInt = ivec2(srcScreen * vec2(extent));
    const uint srcId = uint(srcInt.x + srcInt.y * extent.x);
    const bool srcValid = srcInt.x >= 0 && srcInt.y >= 0 && srcInt.x < extent.x && srcInt.y < extent.y;

    // 
    const vec4 dstHitPersp = vec4(vec4(dstHitFoundIntersection, 1.f) * constants.lookAt, 1.f) * constants.perspective;
    const vec2 dstScreen = (dstHitPersp.xy/dstHitPersp.w * 0.5f + 0.5f);
    const ivec2 dstInt = ivec2(dstScreen * vec2(extent));
    const uint dstId = uint(dstInt.x + dstInt.y * extent.x);
    const bool dstValid = dstInt.x >= 0 && dstInt.y >= 0 && dstInt.x < extent.x && dstInt.y < extent.y;

    // 
    if (srcValid && dstValid) {
      //
      PixelSurfaceInfoRef SURF_SRC = getPixelSurface(srcId);
      PixelHitInfoRef HIT_SRC = getNewHit(srcId, type);

      //
      PixelSurfaceInfoRef SURF_DST = getPixelSurface(dstId);
      PixelHitInfoRef HIT_DST = getRpjHit(dstId, type);  

      // fallback
      vec4 
        srcSamplePos = srcHitPersp/srcHitPersp.w,//vec4(linearSrcPos(srcScreen), 1.f), 
        dstSamplePos = dstHitPersp/dstHitPersp.w;//texture(sampler2D(textures[framebufferAttachments[2]], samplers[0u]), dstScreen);

      // 
      if (HIT_SRC.origin.x != 0.f || HIT_SRC.origin.y != 0.f || HIT_SRC.origin.z != 0.f) { // I don't know, works it or not
        RayData rayData;
        rayData.launchId = u16vec2(srcInt);
        rayData.origin = srcHitFoundIntersection.xyz;
        rayData.direction = normalize(srcHitFoundIntersection.xyz-srcPos.xyz);
        rasterize(instancedData, rayData, 10000.f, srcSamplePos, true);
      };

      //
      if (HIT_DST.origin.x != 0.f || HIT_DST.origin.y != 0.f || HIT_DST.origin.z != 0.f) { // I don't know, works it or not
        RayData rayData;
        rayData.launchId = u16vec2(dstInt);
        rayData.origin = dstHitFoundIntersection.xyz;
        rayData.direction = normalize(dstHitFoundIntersection.xyz-dstPos.xyz);
        rasterize(instancedData, rayData, 10000.f, dstSamplePos, false);
      };

      // sorry, we doesn't save previous raster data
      const bool dstValidDist = all(lessThan(abs(dstSamplePos.xyz-(dstHitPersp.xyz/dstHitPersp.w)), vec3(2.f/extent, 0.002f)));// && distance(dstPos, dstHitFoundIntersection) < 0.001f;
      const bool srcValidDist = true;//all(lessThan(abs(srcSamplePos.xyz-(srcHitPersp.xyz/srcHitPersp.w)), vec3(2.f/extent, 0.002f)));

      // copy to dest, and nullify source
      if ( data.origin.w >= 0.f && SURF_SRC.color[type].w > 0.f && dstValidDist && (srcValidDist || SURF_DST.color[type].w <= 0.f) ) {
        accumulate(SURF_DST, type, cvtRgb16Float(SURF_SRC.color[type])); SURF_SRC.color[type] = vec4(0.f.xxxx);

        // 
        HIT_DST.origin = vec4(dstHitFoundIntersection, distance(dstHitPos, dstHitFoundIntersection)); HIT_SRC.origin = vec4(0.f.xxxx);
        HIT_DST.indices = HIT_SRC.indices; HIT_SRC.indices = uvec4(0u);
      };

    };
  };
};

//
void reprojectDiffuse(in uint srcId, in vec3 srcRayDir) {
  PixelSurfaceInfoRef srcSurface = getPixelSurface(srcId);
  PixelHitInfoRef srcHit = getNewHit(srcId, 2);
  if (srcHit.origin.x != 0.f || srcHit.origin.y != 0.f || srcHit.origin.z != 0.f) {

    //
    const vec3 srcPos = srcSurface.origin.xyz;
    const vec3 srcNormal = srcSurface.normal.xyz;

    //
    const vec3 dstPos = vec4(vec4(srcPos.xyz, 1.f) * inverse(getPreviousInstanceTransform(instancedData, srcSurface.indices.x)), 1.f) * getInstanceTransform(instancedData, srcSurface.indices.x);
    const vec3 dstNormal = normalize(srcNormal.xyz * toNormalMat(getPreviousInstanceTransform(instancedData, srcSurface.indices.x)) * toNormalMat(inverse(getInstanceTransform(instancedData, srcSurface.indices.x))));
    const vec3 dstRayDir = normalize(srcRayDir.xyz * toNormalMat(getPreviousInstanceTransform(instancedData, srcSurface.indices.x)) * toNormalMat(inverse(getInstanceTransform(instancedData, srcSurface.indices.x))));
    const vec4 dstPerspPos = vec4(vec4(dstPos.xyz, 1.f) * constants.lookAt, 1.f) * constants.perspective;
    const vec2 dstScreen = (dstPerspPos.xy/dstPerspPos.w) * 0.5f + 0.5f;
    const ivec2 dstScreenPos = ivec2(dstScreen * vec2(extent));

    // fallback
    vec4 dstSamplePos = dstPerspPos/dstPerspPos.w;//vec4(texture(sampler2D(textures[framebufferAttachments[2]], samplers[0u]), dstScreen, 0).xyz, 1.f);

    //
    if (srcSurface.origin.x != 0.f || srcSurface.origin.y != 0.f || srcSurface.origin.z != 0.f) { // I don't know, works it or not
      RayData rayData;
      rayData.launchId = u16vec2(dstScreenPos);
      rayData.origin = dstPos.xyz;
      rayData.direction = vec3(0.f); // WARNING! BROKEN RAY!
      rasterize(instancedData, rayData, 10000.f, dstSamplePos, false);
    };

    //
    if (dstScreenPos.x >= 0 && dstScreenPos.y >= 0 && dstScreenPos.x < extent.x && dstScreenPos.y < extent.y) {
      const uint dstId = uint(dstScreenPos.x + dstScreenPos.y * extent.x);
      const bool dstValidDist = all(lessThan(abs(dstSamplePos.xyz-(dstPerspPos.xyz/dstPerspPos.w)), vec3(2.f/extent, 0.002f)));
      PixelSurfaceInfoRef dstSurface = getPixelSurface(dstId);
      PixelHitInfoRef dstHit = getRpjHit(dstId, 2);
      if (srcSurface.color[2].w > 0.f && dstValidDist) {
        // 
        accumulate(dstSurface, 2, cvtRgb16Float(srcSurface.color[2]));

        // nullify source
        srcSurface.color[2] = vec4(0.f.xxxx);
      };
    };
  };
};

// 
void main() {
  const uvec2 gcoord = gl_GlobalInvocationID.xy;
  const vec2 tCoord = (vec2(gcoord) + 0.5f)/vec2(extent);
  const uint pixelId = gcoord.x + extent.x * gcoord.y;

  //
  const vec3 srcRayBegin = divW(vec4(vec3(tCoord, 0.f) * 2.f - 1.f, 1.f) * constants.perspectiveInverse) * constants.previousLookAtInverse;//fullTransform(instanceInfo, attrib.data[VERTEX_VERTICES], intersection.geometryId);
  const vec3 srcRayEnd = divW(vec4(vec3(tCoord, 1.f) * 2.f - 1.f, 1.f) * constants.perspectiveInverse) * constants.previousLookAtInverse;
  const vec3 srcRayDir = normalize(srcRayEnd.xyz - srcRayBegin.xyz);

  //
  PixelSurfaceInfoRef srcSurface = getPixelSurface(pixelId);

  // using barrier for partially avoid some problems
  if (srcSurface.origin.x != 0.f || srcSurface.origin.y != 0.f || srcSurface.origin.z != 0.f) {
    reproject3D(pixelId, srcRayDir, 0);
    reproject3D(pixelId, srcRayDir, 1);
    reprojectDiffuse(pixelId, srcRayDir);
  };
  //reproject3D(pixelId, srcRayDir, 2);
};
