#version 460 core

// 
#extension GL_GOOGLE_include_directive : require

//
#include "lib/native.glsl"
#include "lib/raytracing.glsl"
#include "lib/random.glsl"
#include "lib/sphere.glsl"
#include "lib/fresnel.glsl"

//
layout (local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

//
vec3 reflective(in vec3 seed, in vec3 dir, in vec3 normal, in float roughness) {
  return normalize(mix(reflect(dir, normal), randomCosineWeightedHemispherePoint(seed, normal), roughness));
};

//
const vec4 skyColor = vec4(vec3(135.f,206.f,235.f)/vec3(255.f,255.f,255.f), 1.f);

//
RayData pathTrace(in RayData rayData) {
  //
  for (uint32_t i=0;i<3;i++) {
    if (luminance(rayData.energy.xyz) < 0.001f) { break; };

    // 
    vec4 finalPosition = vec4(0.f.xxx, 1.f);
    IntersectionInfo intersection = traceRaysOpaque(instancedData.opaqueAddressInfo, rayData, 10000.f);

    //
    if (!all(lessThanEqual(intersection.barycentric, 0.f.xxx))) {
      InstanceInfo instanceInfo = getInstance(instancedData.opaqueAddressInfo, intersection.instanceId);
      GeometryInfo geometryInfo = getGeometry(instanceInfo, intersection.geometryId);
      GeometryExtData geometry = getGeometryData(geometryInfo, intersection.primitiveId);
      GeometryExtAttrib attrib = interpolate(geometry, intersection.barycentric);

      //
      const vec4 texcoord = attrib.data[VERTEX_TEXCOORD];
      const vec4 vertice = fullTransform(instanceInfo, attrib.data[VERTEX_VERTICES], intersection.geometryId);
      //const vec3 normals = fullTransformNormal(instanceInfo, normalize(attrib.data[VERTEX_NORMALS].xyz), intersection.geometryId);

      //
      mat3x3 tbn = getTBN(attrib);
      MaterialPixelInfo materialPix = handleMaterial(getMaterialInfo(geometryInfo), texcoord.xy, tbn);
      const vec3 normals = inRayNormal(rayData.direction, fullTransformNormal(instanceInfo, attrib.data[VERTEX_NORMALS].xyz, intersection.geometryId));//materialPix.color[MATERIAL_NORMAL].xyz;

      // 
      vec4 emissiveColor = toLinear(materialPix.color[MATERIAL_EMISSIVE]);
      vec4 diffuseColor = toLinear(materialPix.color[MATERIAL_ALBEDO]);
      float metallicFactor = materialPix.color[MATERIAL_PBR].b;
      float roughnessFactor = materialPix.color[MATERIAL_PBR].g;

      //
      if (luminance(materialPix.color[MATERIAL_EMISSIVE].xyz) > 0.001f) {
        rayData.emission.xyz += f16vec3(trueMultColor(rayData.energy.xyz, emissiveColor.xyz));
        rayData.energy.xyz = f16vec3(trueMultColor(rayData.energy.xyz, 1.f-emissiveColor.xyz));
      };

      //
      vec3 originSeedXYZ = vec3(random(rayData.launchId.xy), random(rayData.launchId.xy), random(rayData.launchId.xy));
      if (random(rayData.launchId.xy) <= (metallicFactor + fresnel_schlick(0.f, dot(-rayData.direction.xyz, normals)) * (1.f - metallicFactor))) { // I currently, have no time for fresnel
        rayData.direction.xyz = reflective(originSeedXYZ, rayData.direction.xyz, normals, roughnessFactor);
        rayData.energy.xyz = f16vec3(metallicMult(rayData.energy.xyz, diffuseColor.xyz, metallicFactor));
      } else {
        rayData.direction.xyz = randomCosineWeightedHemispherePoint(originSeedXYZ, normals);
        rayData.energy.xyz = f16vec3(trueMultColor(rayData.energy.xyz, diffuseColor.xyz));
      };
      rayData.origin.xyz = (intersection.hitT * rayData.direction.xyz + rayData.origin.xyz) + outRayNormal(rayData.direction.xyz, normals.xyz) * 0.0001f;
    } else {
      rayData.emission.xyz += f16vec3(trueMultColor(rayData.energy.xyz, toLinear(skyColor.xyz)));
      rayData.energy.xyz *= f16vec3(0.f.xxx);
      rayData.origin.xyz = (10000.f * rayData.direction.xyz + rayData.origin.xyz);
      break;
    }
  };
  return rayData;
};

//
#define USE_RASTERIZE_PASS

//
IntersectionInfo rasterize(in InstanceAddressInfo addressInfo, in RayData rayData, in float maxT) {
  const uvec4 indices = texelFetch(texturesU[framebufferAttachments[1]], ivec2(rayData.launchId), 0);
  const vec3 bary = texelFetch(textures[framebufferAttachments[0]], ivec2(rayData.launchId), 0).xyz;

  IntersectionInfo intersection;
  intersection.barycentric = bary.xyz;
  intersection.instanceId = indices[0];
  intersection.geometryId = indices[1];
  intersection.primitiveId = indices[2];
  return intersection;
};

//
vec3 proj_point_in_plane(in vec3 p, in vec3 v0, in vec3 n, out float d) {
  d = dot(n, p - v0);
  return p - (n * d);
};

//
vec3 find_reflection_incident_point(in vec3 p0, in vec3 p1, in vec3 v0, in vec3 n) {
  float d0 = 0;
  float d1 = 0;
  vec3 proj_p0 = proj_point_in_plane(p0, v0, n, d0);
  vec3 proj_p1 = proj_point_in_plane(p1, v0, n, d1);

  if(d1 < d0)
    return (proj_p0 - proj_p1) * d1/(d0+d1) + proj_p1;
  else
    return (proj_p1 - proj_p0) * d0/(d0+d1) + proj_p0;
};

// 
void main() {
  const uvec2 gcoord = gl_GlobalInvocationID.xy;
  const vec2 tCoord = vec2(gcoord)/vec2(extent);

  // TODO: convert into view space
  const uvec4 prevIndices = imageLoad(imagesRgba32UI[pingpong.images[2]], ivec2(gcoord));
  const uvec4 prevReflIndices = imageLoad(imagesRgba32UI[pingpong.images[10]], ivec2(gcoord));
  const vec4 prevPos = imageLoad(imagesRgba32F[pingpong.images[3]], ivec2(gcoord));
  const vec4 prevReflPos = imageLoad(imagesRgba32F[pingpong.images[8]], ivec2(gcoord));
  const vec4 prevNormal = imageLoad(imagesRgba32F[pingpong.images[9]], ivec2(gcoord));

  // 
  const vec4 currentPos = vec4(vec4(vec4(prevPos.xyz, 1.f) * inverse(getPrevInstanceTransform(instancedData.opaqueAddressInfo, prevIndices.x)), 1.f) * getInstanceTransform(instancedData.opaqueAddressInfo, prevIndices.x), 1.f);
  const vec4 currentReflPos = vec4(vec4(vec4(prevReflPos.xyz, 1.f) * inverse(getPrevInstanceTransform(instancedData.opaqueAddressInfo, prevReflIndices.x)), 1.f) * getInstanceTransform(instancedData.opaqueAddressInfo, prevReflIndices.x), 1.f);
  const vec4 perspPos = vec4(currentPos * constants.lookAt, 1.f) * constants.perspective;
  const vec2 screenPos = ((perspPos.xy/perspPos.w) * 0.5f + 0.5f);
  const ivec2 intScreenPos = ivec2(screenPos * vec2(extent));

  // TODO: correctly reproject previous reflection point
  const vec3 foundIntersection = find_reflection_incident_point(currentReflPos.xyz, prevReflPos.xyz, currentPos.xyz, prevNormal.xyz);
  const vec3 reprojIntersection = vec4(vec4(foundIntersection, 1.f) * inverse(getPrevInstanceTransform(instancedData.opaqueAddressInfo, prevReflIndices.x)), 1.f) * getInstanceTransform(instancedData.opaqueAddressInfo, prevReflIndices.x);

  // 
  const vec3 viewIntersection = vec4(reprojIntersection, 1.f) * constants.lookAt;
  const vec4 SSIntersection = vec4(viewIntersection, 1.f) * constants.perspective;
  const vec2 whereReflect = SSIntersection.xy / SSIntersection.w * 0.5f + 0.5f;
  const ivec2 intWhereReflect = ivec2(whereReflect * vec2(extent));

  // 
  if (distance(texture(sampler2D(textures[framebufferAttachments[2]], samplers[0u]), screenPos, 0).xyz, currentPos.xyz) < 0.001f) {
    accumulateSplit(pingpong.images[1], intScreenPos, imageLoad(imagesRgba32UI[pingpong.images[0]], ivec2(gcoord))); // from previous diffuse
  };

  //
  if (distance(texture(sampler2D(textures[framebufferAttachments[2]], samplers[0u]), whereReflect, 0).xyz, reprojIntersection.xyz) < 0.001f) {
    accumulateSplit(pingpong.images[5], intWhereReflect, imageLoad(imagesRgba32UI[pingpong.images[4]], ivec2(gcoord))); // from previous reflection
  };
};
