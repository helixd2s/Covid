#version 460 core

// 
#extension GL_GOOGLE_include_directive : require

//
#include "lib/native.glsl"
#include "lib/raytracing.glsl"
#include "lib/random.glsl"
#include "lib/sphere.glsl"
#include "lib/fresnel.glsl"
#include "lib/pass.glsl"

//
layout (local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

//
vec3 proj_point_in_plane(in vec3 p, in vec3 v0, in vec3 n, out float d) {
  d = dot(n, p - v0);
  return p - (n * d);
};

//
vec3 find_reflection_incident_point(in vec3 p0, in vec3 p1, in vec3 v0, in vec3 n) {
  float d0 = 0;
  float d1 = 0;
  vec3 proj_p0 = proj_point_in_plane(p0, v0, n, d0);
  vec3 proj_p1 = proj_point_in_plane(p1, v0, n, d1);

  if(d1 < d0)
    return (proj_p0 - proj_p1) * d1/(d0+d1) + proj_p1;
  else
    return (proj_p1 - proj_p0) * d0/(d0+d1) + proj_p0;
};

//
void reproject3D(in PixelSurfaceInfo surface, in PixelHitInfo data, in vec3 prevPos, in vec3 prevPosEnd, in vec3 prevRayDir, in vec3 prevNormal, in int type) {
  //
  const vec3 prevHitPos = prevPos.xyz + data.direction.w * prevRayDir;

  //
  const vec3 currentPos = vec4(vec4(prevPos.xyz, 1.f) * inverse(getPrevInstanceTransform(instancedData.opaqueAddressInfo, surface.indices.x)), 1.f) * getInstanceTransform(instancedData.opaqueAddressInfo, surface.indices.x);
  const vec3 currentHitPos = vec4(vec4(prevHitPos.xyz, 1.f) * inverse(getPrevInstanceTransform(instancedData.opaqueAddressInfo, data.indices.x)), 1.f) * getInstanceTransform(instancedData.opaqueAddressInfo, data.indices.x);
  const vec3 currentPosEnd = vec4(vec4(prevPosEnd.xyz, 1.f) * inverse(getPrevInstanceTransform(instancedData.opaqueAddressInfo, surface.indices.x)), 1.f) * getInstanceTransform(instancedData.opaqueAddressInfo, surface.indices.x);

  //
  const vec3 currentNormal = normalize(prevNormal.xyz * toNormalMat(getPrevInstanceTransform(instancedData.opaqueAddressInfo, surface.indices.x)) * toNormalMat(inverse(getInstanceTransform(instancedData.opaqueAddressInfo, surface.indices.x))));
  const vec3 currentRayDir = normalize(currentPosEnd - currentPos);

  //
  vec3 hitFoundIntersection = find_reflection_incident_point(  prevHitPos.xyz,  prevPos.xyz,  currentHitPos.xyz, normalize(prevNormal.xyz));
  hitFoundIntersection = vec4(vec4(hitFoundIntersection.xyz, 1.f) * inverse(getPrevInstanceTransform(instancedData.opaqueAddressInfo, data.indices.x)), 1.f) * getInstanceTransform(instancedData.opaqueAddressInfo, data.indices.x);

  // 
  const float hitDist = distance(hitFoundIntersection.xyz, currentPos.xyz);
  const vec3 hitOutDir = normalize(hitFoundIntersection.xyz - currentPos.xyz);//currentRayDir;

  //
  const vec4 hitPersp = vec4(vec4(hitFoundIntersection, 1.f) * constants.lookAt, 1.f) * constants.perspective;
  const vec4 hitSurfacePersp = vec4(vec4(hitFoundIntersection - hitOutDir * hitDist, 1.f) * constants.lookAt, 1.f) * constants.perspective;
  const ivec2 intWhere = ivec2((hitPersp.xy/hitPersp.w * 0.5f + 0.5f) * vec2(extent));
  const vec4 hitSampledPos = vec4(texture(sampler2D(textures[framebufferAttachments[2]], samplers[0u]), (hitSurfacePersp.xy/hitSurfacePersp.w) * 0.5f + 0.5f).xyz, 1.f);

  //
  if (distance( hitFoundIntersection.xyz - hitOutDir.xyz * hitDist, hitSampledPos.xyz) < 0.001f && intWhere.x < extent.x && intWhere.y < extent.y && data.color.w > 0.f) {
    uint pix = uint(intWhere.x + intWhere.y * extent.x);
    if (type == 0) { 
      accumulateReflection(pix, cvtRgb16Float(data.color)); 
      pixelData.pixels[pix].reflection.actualDirection = vec4(normalize(hitOutDir), hitDist);
    };
    if (type == 1) { 
      accumulateTransparency(pix, cvtRgb16Float(data.color)); 
      pixelData.pixels[pix].transparency.actualDirection = vec4(normalize(hitOutDir), hitDist);
    };
  };

};

//
void reprojectDiffuse(in PixelSurfaceInfo surface, in PixelHitInfo data, in vec3 prevPos, in vec3 prevPosEnd, in vec3 prevRayDir, in vec3 prevNormal) {
  //
  const vec3 currentPos = vec4(vec4(prevPos.xyz, 1.f) * inverse(getPrevInstanceTransform(instancedData.opaqueAddressInfo, surface.indices.x)), 1.f) * getInstanceTransform(instancedData.opaqueAddressInfo, surface.indices.x);
  const vec3 currentNormal = normalize(prevNormal.xyz * toNormalMat(getPrevInstanceTransform(instancedData.opaqueAddressInfo, surface.indices.x)) * toNormalMat(inverse(getInstanceTransform(instancedData.opaqueAddressInfo, surface.indices.x))));
  const vec3 currentRayDir = normalize(prevRayDir.xyz * toNormalMat(getPrevInstanceTransform(instancedData.opaqueAddressInfo, surface.indices.x)) * toNormalMat(inverse(getInstanceTransform(instancedData.opaqueAddressInfo, surface.indices.x))));

  //
  const vec4 perspPos = vec4(vec4(currentPos.xyz, 1.f) * constants.lookAt, 1.f) * constants.perspective;
  const vec4 sampledPos = vec4(texture(sampler2D(textures[framebufferAttachments[2]], samplers[0u]), (perspPos.xy/perspPos.w) * 0.5f + 0.5f, 0).xyz, 1.f);
  const ivec2 intScreenPos = ivec2(((perspPos.xy/perspPos.w) * 0.5f + 0.5f) * vec2(extent));

  //
  if (distance( sampledPos.xyz, currentPos.xyz) < 0.001f && intScreenPos.x < extent.x && intScreenPos.y < extent.y && data.color.w > 0.f) {
    uint pix = uint(intScreenPos.x + intScreenPos.y * extent.x);
    accumulateDiffuse(pix, cvtRgb16Float(data.color));
    accumulateDiffuseTex(pix, cvtRgb16Float(surface.diffuse));
    accumulateEmissiveTex(pix, cvtRgb16Float(surface.emission));
    pixelData.pixels[pix].surface.actualOrigin.xyz = currentPos.xyz;
    pixelData.pixels[pix].surface.actualNormal.xyz = currentNormal.xyz;
  };
}

// 
void main() {
  const uvec2 gcoord = gl_GlobalInvocationID.xy;
  const vec2 tCoord = vec2(gcoord)/vec2(extent);
  const uint pixelId = gcoord.x + extent.x * gcoord.y;

  //
  const vec3 prevRayBegin = divW(vec4(vec3(tCoord, 0.f) * 2.f - 1.f, 1.f) * constants.perspectiveInverse) * constants.previousLookAtInverse;//fullTransform(instanceInfo, attrib.data[VERTEX_VERTICES], intersection.geometryId);
  const vec3 prevRayEnd = divW(vec4(vec3(tCoord, 1.f) * 2.f - 1.f, 1.f) * constants.perspectiveInverse) * constants.previousLookAtInverse;
  const vec3 prevPos = pixelData.pixels[pixelId].surface.origin.xyz;
  const vec3 prevRayDir = normalize(prevRayEnd.xyz - prevRayBegin.xyz);
  const vec3 prevNormal = pixelData.pixels[pixelId].surface.normal.xyz;

  //
  reprojectDiffuse(pixelData.pixels[pixelId].surface, pixelData.pixels[pixelId].diffuse, prevPos, prevRayEnd, prevRayDir, prevNormal);
  reproject3D(pixelData.pixels[pixelId].surface, pixelData.pixels[pixelId].reflection, prevPos, prevRayEnd, prevRayDir, prevNormal, 0);
  reproject3D(pixelData.pixels[pixelId].surface, pixelData.pixels[pixelId].transparency, prevPos, prevRayEnd, prevRayDir, prevNormal, 1);
};
