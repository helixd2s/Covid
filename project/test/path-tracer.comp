#version 460 core

// 
#extension GL_GOOGLE_include_directive : require

//
#define ENABLE_CHECKERBOARD
#define USE_RASTERIZE_PASS

//
#include "lib/raytracing.glsl"
#include "lib/pupet.glsl"

//
layout (local_size_x = 32, local_size_y = 8, local_size_z = 1) in;

// 
void main() {
#ifdef ENABLE_CHECKERBOARD
  const uvec2 gcoord_ = gl_GlobalInvocationID.xy;
#endif
  {
#ifdef ENABLE_CHECKERBOARD
    const bool firstPart = gcoord_.y < (extent.y/2);
    const uvec2 gcoord = firstPart ? uvec2(gcoord_.x, gcoord_.y * 2 + ((gcoord_.x&1)^(frameCounter&1))) : uvec2(gcoord_.x, (gcoord_.y - (extent.y/2)) * 2u + ((gcoord_.x&1u)^(1u-(frameCounter&1u))));
#else
    const bool firstPart = true;
    const uvec2 gcoord = gl_GlobalInvocationID.xy;
#endif

    // 
    const vec2 tCoord = (vec2(gcoord)+0.5f)/vec2(extent);
    const uint pixelId = gcoord.x + extent.x * gcoord.y;

    //
    vec4 ssEye = vec4(vec3(tCoord, 0.5f) * 2.f - 1.f, 1.f);
    vec3 rayBegin = divW(ssEye * constants.perspectiveInverse) * constants.lookAtInverse;//fullTransform(instanceInfo, attrib.data[VERTEX_VERTICES], intersection.geometryId);
    vec3 rayEnd = divW(vec4(vec3(tCoord, 1.f) * 2.f - 1.f, 1.f) * constants.perspectiveInverse) * constants.lookAtInverse;
    vec3 rayDir = normalize(rayEnd.xyz - rayBegin.xyz);

    //
    RayData rayData;
    rayData.launchId = u16vec2(gcoord.xy);
    rayData.origin = rayBegin.xyz;
    rayData.direction = rayDir;
    rayData.energy = f16vec4(1.f.xxx, 1.f);
    rayData.emission = f16vec4(0.f.xxx, 1.f);

    //
  #ifdef USE_RASTERIZE_PASS
    vec4 ssLastPos = ssEye;
    IntersectionInfo intersection = rasterize(instancedData.opaqueAddressInfo, rayData, 10000.f, ssLastPos, false);
  #else
    IntersectionInfo intersection = traceRaysOpaque(instancedData.opaqueAddressInfo, rayData, 10000.f);
  #endif

    // 
    InstanceInfo instanceInfo = getInstance(instancedData.opaqueAddressInfo, intersection.instanceId);
    GeometryInfo geometryInfo = getGeometry(instanceInfo, intersection.geometryId);
    GeometryExtData geometry = getGeometryData(geometryInfo, intersection.primitiveId);
    GeometryExtAttrib attrib = interpolate(geometry, intersection.barycentric);

    //
    PathTraceCommand cmd;
    cmd.pixelId = pixelId;
    cmd.intersection = intersection;
    cmd.hasHit = !all(lessThanEqual(cmd.intersection.barycentric, 0.f.xxx));
    cmd.rayData = rayData;
    cmd.rayData.origin = cmd.hasHit ? fullTransform(instanceInfo, attrib.data[VERTEX_VERTICES], intersection.geometryId).xyz : (vec4(0.f.xxx, 1.f) * constants.lookAtInverse + cmd.rayData.direction * 10000.f);
    cmd.tbn = getTBN(attrib); //cmd.rayData.origin += outRayNormal(cmd.rayData.direction.xyz, cmd.tbn[2].xyz) * 0.0001f;
    cmd.tbn[0] = fullTransformNormal(instanceInfo, cmd.tbn[0], intersection.geometryId);
    cmd.tbn[1] = fullTransformNormal(instanceInfo, cmd.tbn[1], intersection.geometryId);
    cmd.tbn[2] = fullTransformNormal(instanceInfo, cmd.tbn[2], intersection.geometryId);

    //
    const bool inner = dot(cmd.tbn[2], cmd.rayData.direction.xyz) > 0.f;

    //
    const MaterialPixelInfo materialPix = handleMaterial(getMaterialInfo(geometryInfo), attrib.data[VERTEX_TEXCOORD].xy, cmd.tbn);
    const vec4 skyColor = gamma3(vec4(texture(sampler2D(textures[background], samplers[0]), lcts(cmd.rayData.direction.xyz)).xyz, 1.f));

    //
    cmd.normals = inRayNormal(cmd.rayData.direction.xyz, materialPix.color[MATERIAL_NORMAL].xyz);
    cmd.diffuseColor = toLinear(cmd.hasHit ? materialPix.color[MATERIAL_ALBEDO] : vec4(skyColor.xyz, 1.f));
    cmd.emissiveColor = toLinear(cmd.hasHit ? materialPix.color[MATERIAL_EMISSIVE] : vec4(0.f.xxx, 1.f)).xyz * 2.f;

    //
    cmd.PBR = cmd.hasHit ? materialPix.color[MATERIAL_PBR].xyz : 0.f.xxx;
    cmd.reflCoef = (cmd.PBR.b + mix(fresnel_schlick(0.f, dot(reflect(cmd.rayData.direction.xyz, cmd.normals), cmd.normals)), 0.f, cmd.PBR.g) * (1.f - cmd.PBR.b)) * (1.f - luminance(cmd.emissiveColor.xyz));

    //
    retranslateSurface(cmd);
    retranslateHit(pixelId, 0, cmd.rayData.origin);
    retranslateHit(pixelId, 1, cmd.rayData.origin);
    retranslateHit(pixelId, 2, cmd.rayData.origin);

    // 
    if (cmd.hasHit) {
      pathTraceCommand(cmd, firstPart && (cmd.diffuseColor.a >= 0.001f && luminance(cmd.diffuseColor.xyz) > 0.f) ? 2 : 0);
      if (cmd.diffuseColor.a < 1.f) { pathTraceCommand(cmd, 1); } else { blankHit(cmd, 1); };
    } else {
      backgroundHit(pixelId, 0, rayData.origin);
      backgroundHit(pixelId, 1, rayData.origin);
      backgroundHit(pixelId, 2, rayData.origin);
    };
  };
};
