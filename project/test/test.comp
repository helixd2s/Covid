#version 460 core

// 
#extension GL_GOOGLE_include_directive : require

//
#include "lib/native.glsl"
#include "lib/raytracing.glsl"
#include "lib/random.glsl"
#include "lib/sphere.glsl"
#include "lib/fresnel.glsl"
#include "lib/pass.glsl"

//
layout (local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

//
#define ENABLE_CHECKERBOARD

//
struct PathTraceCommand {
  RayData rayData;
  PixelSurfaceInfoRef surface;
  IntersectionInfo intersection;
  vec3 normals;
  vec3 rayDir;
  vec3 PBR;
  mat3x3 tbn;
  uint pixelId;
  float reflCoef;
  vec4 diffuseColor;
  vec3 emissiveColor;
  bool hasHit;
};

//
struct PathTraceOutput {
  vec3 normals; float hitT;
  uvec4 indices;
};

//
PathTraceOutput pathTraceCommand(in PathTraceCommand cmd, in uint type) {
  RayData rayData = cmd.rayData;

  //
  vec3 originSeedXYZ = vec3(random(rayData.launchId.xy), random(rayData.launchId.xy), random(rayData.launchId.xy));
  PathTraceOutput outp;

  // 
  if (type == 0) {
    rayData.direction.xyz = normalize(reflective(originSeedXYZ, rayData.direction.xyz, cmd.normals.xyz, cmd.PBR.g));;
    rayData.energy = f16vec4(metallicMult(1.f.xxx, cmd.diffuseColor.xyz, cmd.PBR.b), 1.f);
    rayData.emission = f16vec4(0.f.xxx, 1.f);
  } else 
  if (type == 1) {
    //rayData.direction.xyz = rayData.direction.xyz;
    rayData.energy = f16vec4(1.f.xxx, 1.f);//f16vec4(metallicMult(1.f.xxx, materialPix.color[MATERIAL_ALBEDO].xyz, metallicFactor), 1.f);
    rayData.emission = f16vec4(0.f.xxx, 1.f);
  } else {
    rayData.direction.xyz = normalize(randomCosineWeightedHemispherePoint(originSeedXYZ, cmd.normals));
    rayData.energy = f16vec4(1.f.xxx, 1.f);
    rayData.emission = f16vec4(0.f.xxx, 1.f);
  };

  //
  rayData.origin += outRayNormal(rayData.direction.xyz, cmd.tbn[2].xyz) * 0.0001f;
  rayData = pathTrace(rayData, outp.hitT, outp.normals, outp.indices);

  //
  vec4 finalColor = vec4(vec3(rayData.emission.xyz), 1.f);
  finalColor = clamp(finalColor, vec4(0.f.xxx, 1.f), vec4(16.f.xxx, 1.f));

  //
  float transpCoef = cmd.diffuseColor.a;
  float reflCoef = cmd.reflCoef;

  // 
  vec4 additional = vec4(0.f);
  if (type == 0) { additional = finalColor * vec4(reflCoef.xxx, 1.f); };
  if (type == 1) { additional = finalColor * vec4(((1.f - reflCoef) * (1.f - transpCoef)).xxx, 1.f); };
  if (type == 2) { additional = finalColor * vec4(((1.f - reflCoef) * transpCoef).xxx, 1.f); };

  //
  PixelHitInfoRef hitInfo = getPixelHitInfo(cmd.pixelId, type);
  hitInfo.color += additional;
  hitInfo.accum = TYPE(0u);
  hitInfo.indices = outp.indices;
  hitInfo.direction = vec4(cmd.rayData.origin.xyz, 0.f);
  hitInfo.actualDirection = vec4(0.f);

  // 
  return outp;
};

//
void retranslateSurface(in uint pixelId) {
  PixelSurfaceInfoRef surfaceInfo = getPixelSurface(pixelId);
  surfaceInfo.indices = uvec4(0u.xxxx);
  surfaceInfo.origin = surfaceInfo.actualOrigin;
  surfaceInfo.normal = surfaceInfo.actualNormal;
  surfaceInfo.emission = cvtRgb16Acc(surfaceInfo.emissionAccum);
  surfaceInfo.diffuse = cvtRgb16Acc(surfaceInfo.diffuseAccum);
  surfaceInfo.emissionAccum = TYPE(0u);
  surfaceInfo.diffuseAccum = TYPE(0u);
  surfaceInfo.actualOrigin = vec3(0.f);
  surfaceInfo.actualNormal = vec3(0.f);
};

// 
void initialSurface(in PathTraceCommand cmd) {
  PixelSurfaceInfoRef surfaceInfo = getPixelSurface(cmd.pixelId);
  surfaceInfo.indices = uvec4(cmd.intersection.instanceId, cmd.intersection.geometryId, cmd.intersection.primitiveId, 0u);
  surfaceInfo.origin = cmd.rayData.origin.xyz;
  surfaceInfo.normal = cmd.normals;//tbn[2].xyz;
  surfaceInfo.emission = vec4(cmd.emissiveColor.xyz * (1.f - cmd.reflCoef), 1.f);
  surfaceInfo.diffuse = vec4(cmd.diffuseColor.xyz, 1.f);
  surfaceInfo.emissionAccum = TYPE(0u);
  surfaceInfo.diffuseAccum = TYPE(0u);
  surfaceInfo.actualOrigin = vec3(0.f);
  surfaceInfo.actualNormal = vec3(0.f);
};

//
void retranslateHit(in uint pixelId, in uint type) {
  PixelHitInfoRef hitInfo = getPixelHitInfo(pixelId, type);
  hitInfo.color = cvtRgb16Acc(hitInfo.accum);
  hitInfo.accum = TYPE(0u);
  hitInfo.direction = hitInfo.actualDirection;
  hitInfo.actualDirection = vec4(0.f);
};

//
void backgroundHit(in uint pixelId, in uint type, in vec3 rayEnd) {
  PixelHitInfoRef hitInfo = getPixelHitInfo(pixelId, type);
  hitInfo.color = ((type == 2) ? vec4(1.f.xxxx) : vec4(0.f.xxx, 1.f));// + ;
  hitInfo.accum = TYPE(0u);
  hitInfo.direction = vec4(rayEnd, 10000.f);
  hitInfo.actualDirection = vec4(0.f);
};

// 
void main() {
#ifdef ENABLE_CHECKERBOARD
  const uvec2 gcoord_ = gl_GlobalInvocationID.xy;
  if (gcoord_.y < (extent.y/2)) 
#endif
  {
#ifdef ENABLE_CHECKERBOARD
    const uvec2 gcoord = uvec2(gcoord_.x, gcoord_.y * 2 + ((gcoord_.x&1)^(frameCounter&1)));
#else
    const uvec2 gcoord = gl_GlobalInvocationID.xy;
#endif

    const vec2 tCoord = vec2(gcoord)/vec2(extent);
    const uint pixelId = gcoord.x + extent.x * gcoord.y;

    //
    const vec3 rayBegin = divW(vec4(vec3(tCoord, 0.f) * 2.f - 1.f, 1.f) * constants.perspectiveInverse) * constants.lookAtInverse;//fullTransform(instanceInfo, attrib.data[VERTEX_VERTICES], intersection.geometryId);
    const vec3 rayEnd = divW(vec4(vec3(tCoord, 1.f) * 2.f - 1.f, 1.f) * constants.perspectiveInverse) * constants.lookAtInverse;
    const vec3 rayDir = normalize(rayEnd.xyz - rayBegin.xyz);

    //
    RayData rayData;
    rayData.launchId = u16vec2(gcoord.xy);
    rayData.origin = rayBegin.xyz;
    rayData.direction = rayDir;
    rayData.energy = f16vec4(1.f.xxx, 1.f);
    rayData.emission = f16vec4(0.f.xxx, 1.f);

    //
  #ifdef USE_RASTERIZE_PASS
    IntersectionInfo intersection = rasterize(instancedData.opaqueAddressInfo, rayData, 10000.f);
  #else
    IntersectionInfo intersection = traceRaysOpaque(instancedData.opaqueAddressInfo, rayData, 10000.f);
  #endif

    // 
    InstanceInfo instanceInfo = getInstance(instancedData.opaqueAddressInfo, intersection.instanceId);
    GeometryInfo geometryInfo = getGeometry(instanceInfo, intersection.geometryId);
    GeometryExtData geometry = getGeometryData(geometryInfo, intersection.primitiveId);
    GeometryExtAttrib attrib = interpolate(geometry, intersection.barycentric);

    //
    PathTraceCommand cmd;
    cmd.pixelId = pixelId;
    cmd.rayData = rayData;
    cmd.rayData.origin = fullTransform(instanceInfo, attrib.data[VERTEX_VERTICES], intersection.geometryId).xyz;
    cmd.tbn = getTBN(attrib); //cmd.rayData.origin += outRayNormal(cmd.rayData.direction.xyz, cmd.tbn[2].xyz) * 0.0001f;
    cmd.intersection = intersection;

    //
    const MaterialPixelInfo materialPix = handleMaterial(getMaterialInfo(geometryInfo), attrib.data[VERTEX_TEXCOORD].xy, cmd.tbn);
    const vec4 skyColor = pow(texture(sampler2D(textures[background], samplers[0]), lcts(cmd.rayData.direction.xyz)), vec4(1.f/2.2f.xxx, 1.f));

    //
    cmd.normals = inRayNormal(cmd.rayData.direction.xyz, fullTransformNormal(instanceInfo, materialPix.color[MATERIAL_NORMAL].xyz, intersection.geometryId));
    cmd.hasHit = !all(lessThanEqual(intersection.barycentric, 0.f.xxx));
    cmd.diffuseColor = toLinear(cmd.hasHit ? materialPix.color[MATERIAL_ALBEDO] : vec4(skyColor.xyz, 1.f));
    cmd.emissiveColor = toLinear(cmd.hasHit ? materialPix.color[MATERIAL_EMISSIVE] : vec4(0.f.xxx, 1.f)).xyz;
    cmd.PBR = cmd.hasHit ? materialPix.color[MATERIAL_PBR].xyz : 0.f.xxx;
    cmd.reflCoef = (cmd.PBR.b + (fresnel_schlick(0.f, dot(reflect(cmd.rayData.direction.xyz, cmd.normals), cmd.normals))) * (1.f - cmd.PBR.b)) * (1.f - luminance(cmd.emissiveColor.xyz));

    //
    //retranslateSurface(pixelId);
    initialSurface(cmd);
    retranslateHit(pixelId, 0);
    retranslateHit(pixelId, 1);
    retranslateHit(pixelId, 2);

    // 
    if (cmd.hasHit) {
      pathTraceCommand(cmd, 0);
      pathTraceCommand(cmd, 1);
      pathTraceCommand(cmd, 2);
    } else {
      backgroundHit(pixelId, 0, rayEnd);
      backgroundHit(pixelId, 1, rayEnd);
      backgroundHit(pixelId, 2, rayEnd);
    };
  }
#ifdef ENABLE_CHECKERBOARD
  else {
    const uvec2 gcoord = uvec2(gcoord_.x, (gcoord_.y - (extent.y/2)) * 2u + ((gcoord_.x&1u)^(1u-(frameCounter&1u))));
    const uint pixelId = gcoord.x + extent.x * gcoord.y;

    retranslateSurface(pixelId);
    retranslateHit(pixelId, 0);
    retranslateHit(pixelId, 1);
    retranslateHit(pixelId, 2);
  };
#endif
};
