#version 460 core

// 
#extension GL_GOOGLE_include_directive : require

//
#include "lib/native.glsl"
#include "lib/raytracing.glsl"
#include "lib/random.glsl"
#include "lib/sphere.glsl"
#include "lib/fresnel.glsl"
#include "lib/pass.glsl"

//
layout (local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

//
#define ENABLE_CHECKERBOARD

// 
void main() {
#ifdef ENABLE_CHECKERBOARD
  const uvec2 gcoord_ = gl_GlobalInvocationID.xy;
  if (gcoord_.y < (extent.y/2)) 
#endif
  {
#ifdef ENABLE_CHECKERBOARD
    const uvec2 gcoord = uvec2(gcoord_.x, gcoord_.y * 2 + ((gcoord_.x&1)^(frameCounter&1)));
#else
    const uvec2 gcoord = gl_GlobalInvocationID.xy;
#endif

    const vec2 tCoord = vec2(gcoord)/vec2(extent);
    const uint pixelId = gcoord.x + extent.x * gcoord.y;

    //
    const vec3 rayBegin = divW(vec4(vec3(tCoord, 0.f) * 2.f - 1.f, 1.f) * constants.perspectiveInverse) * constants.lookAtInverse;//fullTransform(instanceInfo, attrib.data[VERTEX_VERTICES], intersection.geometryId);
    const vec3 rayEnd = divW(vec4(vec3(tCoord, 1.f) * 2.f - 1.f, 1.f) * constants.perspectiveInverse) * constants.lookAtInverse;
    const vec3 rayDir = normalize(rayEnd.xyz - rayBegin.xyz);
    
    //
    RayData rayData;
    rayData.launchId = u16vec2(gcoord.xy);
    rayData.origin = rayBegin.xyz;
    rayData.direction = rayDir;
    rayData.energy = f16vec4(1.f.xxx, 1.f);
    rayData.emission = f16vec4(0.f.xxx, 1.f);

    //
  #ifdef USE_RASTERIZE_PASS
    IntersectionInfo intersection = rasterize(instancedData.opaqueAddressInfo, rayData, 10000.f);
  #else
    IntersectionInfo intersection = traceRaysOpaque(instancedData.opaqueAddressInfo, rayData, 10000.f);
  #endif

    // 
    InstanceInfo instanceInfo = getInstance(instancedData.opaqueAddressInfo, intersection.instanceId);
    GeometryInfo geometryInfo = getGeometry(instanceInfo, intersection.geometryId);
    GeometryExtData geometry = getGeometryData(geometryInfo, intersection.primitiveId);
    GeometryExtAttrib attrib = interpolate(geometry, intersection.barycentric);

    //
    const vec3 rayOrigin = fullTransform(instanceInfo, attrib.data[VERTEX_VERTICES], intersection.geometryId).xyz;
    const vec4 texcoord = attrib.data[VERTEX_TEXCOORD];
    const vec4 tangent = attrib.data[VERTEX_TANGENT];

    //
    mat3x3 tbn = getTBN(attrib);
    MaterialPixelInfo materialPix = handleMaterial(getMaterialInfo(geometryInfo), texcoord.xy, tbn);
    const vec3 mNormal = materialPix.color[MATERIAL_NORMAL].xyz;
    const vec3 normals = inRayNormal(rayDir, fullTransformNormal(instanceInfo, mNormal, intersection.geometryId));
    bool hasHit = !all(lessThanEqual(intersection.barycentric, 0.f.xxx));

    // 
    vec4 skyColor = pow(texture(sampler2D(textures[background], samplers[0]), lcts(rayDir)), vec4(1.f/2.2f.xxx, 1.f));
    vec4 diffuseColor = toLinear(hasHit ? materialPix.color[MATERIAL_ALBEDO] : vec4(skyColor.xyz, 1.f));
    vec4 emissiveColor = toLinear(hasHit ? materialPix.color[MATERIAL_EMISSIVE] : vec4(0.f.xxx, 1.f));
    float metallicFactor = hasHit ? materialPix.color[MATERIAL_PBR].b : 0.f;
    float roughnessFactor = hasHit ? materialPix.color[MATERIAL_PBR].g : 0.f;
    vec3 originSeedXYZ = vec3(random(rayData.launchId.xy), random(rayData.launchId.xy), random(rayData.launchId.xy));

    // 
    vec4 finalColor = vec4(1.f.xxx, 1.f);
    vec4 reflColor = vec4(0.f.xxx, 0.f);
    vec4 transpColor = vec4(0.f.xxx, 0.f);

    //
    RayData reflRayData = rayData;
    RayData diffRayData = rayData;
    RayData transpRayData = rayData;

    //
    const vec3 reflDir = normalize(reflective(originSeedXYZ, rayDir.xyz, normals.xyz, roughnessFactor));
    const vec3 diffuseDir = normalize(randomCosineWeightedHemispherePoint(originSeedXYZ, normals));

    //
    uvec4 reflIndices = uvec4(0u), diffuseIndices = uvec4(0u), transpIndices = uvec4(0u);
    vec4 reflHit = vec4(rayOrigin, 10000.f), diffuseHit = vec4(rayOrigin, 10000.f), transpHit = vec4(rayOrigin, 10000.f);
    vec3 reflNorm = 0.f.xxx, diffuseNorm = 0.f.xxx, transpNorm = 0.f.xxx;

    // 
    if (hasHit) {
      // 
      diffRayData.direction.xyz = diffuseDir;
      diffRayData.origin = rayOrigin.xyz + outRayNormal(diffRayData.direction.xyz, normals.xyz) * 0.0001f;
      diffRayData.energy = f16vec4(1.f.xxx, 1.f);
      diffRayData.emission = f16vec4(0.f.xxx, 1.f);
      diffRayData = luminance(diffuseColor.xyz) >= 0.001f ? pathTrace(diffRayData, diffuseHit, reflNorm, diffuseIndices) : diffRayData;

      // 
      reflRayData.direction.xyz = reflDir;
      reflRayData.origin = rayOrigin.xyz + outRayNormal(reflRayData.direction.xyz, normals.xyz) * 0.0001f;
      reflRayData.energy = f16vec4(metallicMult(1.f.xxx, materialPix.color[MATERIAL_ALBEDO].xyz, metallicFactor), 1.f);
      reflRayData.emission = f16vec4(0.f.xxx, 1.f);
      reflRayData = pathTrace(reflRayData, reflHit, diffuseNorm, reflIndices);

      //
      if (diffuseColor.a < 1.f) {
        transpRayData.direction.xyz = rayDir;
        transpRayData.origin = rayOrigin.xyz + outRayNormal(transpRayData.direction.xyz, normals.xyz) * 0.0001f;
        transpRayData.energy = f16vec4(1.f.xxx, 1.f);//f16vec4(metallicMult(1.f.xxx, materialPix.color[MATERIAL_ALBEDO].xyz, metallicFactor), 1.f);
        transpRayData.emission = f16vec4(0.f.xxx, 1.f);
        transpRayData = pathTrace(transpRayData, transpHit, transpNorm, transpIndices);
      };

      // I currently, have no time for fresnel
      reflColor = vec4(vec3(reflRayData.emission.xyz), 1.f);
      finalColor = vec4(vec3(diffRayData.emission.xyz), 1.f);
      transpColor = vec4(vec3(transpRayData.emission.xyz), 1.f);
    };

    //
    float reflCoef = clamp(hasHit ? (metallicFactor + (fresnel_schlick(0.f, dot(reflDir.xyz, normals))) * (1.f - metallicFactor)) : 0.f, 0.f, 1.f);
    vec4 origRefl = cvtRgb16Acc(pixelData.pixels[pixelId].reflection.accum) + clamp(reflColor * reflCoef, vec4(0.f.xxx, 1.f), vec4(16.f.xxx, 1.f));
    vec4 origTransp = cvtRgb16Acc(pixelData.pixels[pixelId].transparency.accum) + clamp(transpColor * (1.f - reflCoef), vec4(0.f.xxx, 1.f), vec4(16.f.xxx, 1.f));
    vec4 origDiffuse = cvtRgb16Acc(pixelData.pixels[pixelId].diffuse.accum) + clamp(finalColor * (1.f - reflCoef), vec4(0.f.xxx, 1.f), vec4(16.f.xxx, 1.f));

    //
    pixelData.pixels[pixelId].diffuse.color = origDiffuse;
    pixelData.pixels[pixelId].diffuse.accum = uvec4(0u);
    pixelData.pixels[pixelId].diffuse.indices = diffuseIndices;
    pixelData.pixels[pixelId].diffuse.direction = vec4(diffRayData.direction.xyz, distance(transpHit.xyz, rayOrigin.xyz));
    pixelData.pixels[pixelId].diffuse.actualDirection = vec4(0.f);

    pixelData.pixels[pixelId].reflection.color = origRefl;
    pixelData.pixels[pixelId].reflection.accum = uvec4(0u);
    pixelData.pixels[pixelId].reflection.indices = reflIndices;
    pixelData.pixels[pixelId].reflection.direction = vec4(reflRayData.direction.xyz, distance(reflHit.xyz, rayOrigin.xyz));
    pixelData.pixels[pixelId].reflection.actualDirection = vec4(0.f);

    pixelData.pixels[pixelId].transparency.color = origTransp;
    pixelData.pixels[pixelId].transparency.accum = uvec4(0u);
    pixelData.pixels[pixelId].transparency.indices = transpIndices;
    pixelData.pixels[pixelId].transparency.direction = vec4(transpRayData.direction.xyz, distance(transpHit.xyz, rayOrigin.xyz));
    pixelData.pixels[pixelId].transparency.actualDirection = vec4(0.f);

    pixelData.pixels[pixelId].surface.origin = rayOrigin.xyz;
    pixelData.pixels[pixelId].surface.normal = tbn[2].xyz;
    pixelData.pixels[pixelId].surface.indices = uvec4(intersection.instanceId, intersection.geometryId, intersection.primitiveId, 0u);
    pixelData.pixels[pixelId].surface.emission = vec4(emissiveColor * (1.f - reflCoef));
    pixelData.pixels[pixelId].surface.diffuse = diffuseColor;
    pixelData.pixels[pixelId].surface.actualOrigin = vec3(0.f);
    pixelData.pixels[pixelId].surface.actualNormal = vec3(0.f);
  }
#ifdef ENABLE_CHECKERBOARD
  else {
    const uvec2 gcoord = uvec2(gcoord_.x, (gcoord_.y - (extent.y/2)) * 2u + ((gcoord_.x&1u)^(1u-(frameCounter&1u))));
    const uint pixelId = gcoord.x + extent.x * gcoord.y;

    // actualize
    pixelData.pixels[pixelId].surface.origin = pixelData.pixels[pixelId].surface.actualOrigin;
    pixelData.pixels[pixelId].surface.normal = pixelData.pixels[pixelId].surface.actualNormal;
    pixelData.pixels[pixelId].surface.actualOrigin = vec3(0.f);
    pixelData.pixels[pixelId].surface.actualNormal = vec3(0.f);
    pixelData.pixels[pixelId].diffuse.direction = pixelData.pixels[pixelId].diffuse.actualDirection;
    pixelData.pixels[pixelId].diffuse.color = cvtRgb16Acc(pixelData.pixels[pixelId].diffuse.accum);
    pixelData.pixels[pixelId].diffuse.accum = uvec4(0u);
    pixelData.pixels[pixelId].diffuse.actualDirection = vec4(0.f);
    pixelData.pixels[pixelId].reflection.direction = pixelData.pixels[pixelId].reflection.actualDirection;
    pixelData.pixels[pixelId].reflection.color = cvtRgb16Acc(pixelData.pixels[pixelId].reflection.accum);
    pixelData.pixels[pixelId].reflection.accum = uvec4(0u);
    pixelData.pixels[pixelId].reflection.actualDirection = vec4(0.f);
    pixelData.pixels[pixelId].transparency.direction = pixelData.pixels[pixelId].transparency.actualDirection;
    pixelData.pixels[pixelId].transparency.color = cvtRgb16Acc(pixelData.pixels[pixelId].transparency.accum);
    pixelData.pixels[pixelId].transparency.accum = uvec4(0u);
    pixelData.pixels[pixelId].transparency.actualDirection = vec4(0.f);
  };
#endif
};
