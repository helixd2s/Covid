#version 460 core

// 
#extension GL_GOOGLE_include_directive : require

//
#include "lib/native.glsl"
#include "lib/raytracing.glsl"

//
layout (local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

// 
void main() {
  const vec2 tCoord = vec2(gl_GlobalInvocationID.xy)/vec2(extent);
  const vec3 rayOrigin = divW(vec4(vec3(tCoord, 0.f) * 2.f - 1.f, 1.f) * constants.perspectiveInverse) * constants.lookAtInverse;
  const vec3 rayEnd = divW(vec4(vec3(tCoord, 1.f) * 2.f - 1.f, 1.f) * constants.perspectiveInverse) * constants.lookAtInverse;
  const vec3 rayDir = normalize(rayEnd - rayOrigin);
  vec4 payload = vec4(0.3f, 0.3f, 0.3f, 1.f);

  // 
  RayData rayData;
  rayData.origin = rayOrigin;
  rayData.direction = rayDir;

  //vec4 finalPosition = texelFetch(textures[framebufferAttachments[0]], ivec2(gl_GlobalInvocationID.xy), 0);
  vec4 finalPosition = vec4(0.f.xxx, 1.f);
  IntersectionInfo intersection = traceRaysOpaque(instancedData.opaqueAddressInfo, rayData, 10000.f);
  InstanceInfo instanceInfo = getInstance(instancedData.opaqueAddressInfo, intersection.instanceId);
  GeometryInfo geometryInfo = getGeometry(instanceInfo, intersection.geometryId);
  GeometryExtData geometry = getGeometryData(geometryInfo, intersection.primitiveId);
  GeometryExtAttrib attrib = interpolate(geometry, intersection.barycentric);

  const vec4 vertice = attrib.data[VERTEX_VERTICES];
  const vec4 texcoord = attrib.data[VERTEX_TEXCOORD];
  finalPosition.xyz = texcoord.xyz;

  // 
  imageStore(images[swapchain.image], ivec2(gl_GlobalInvocationID.xy), vec4(finalPosition.xyz, 1.f));
};
