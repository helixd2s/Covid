#version 460 core

// 
#extension GL_GOOGLE_include_directive : require

//
#include "lib/native.glsl"
#include "lib/raytracing.glsl"
#include "lib/random.glsl"
#include "lib/sphere.glsl"
#include "lib/fresnel.glsl"
#include "lib/pass.glsl"

//
layout (local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

//
#define ENABLE_CHECKERBOARD

//
struct PathTraceCommand {
  RayData rayData;
  PixelSurfaceInfoRef surface;
  IntersectionInfo intersection;
  vec3 normals;
  vec3 rayDir;
  vec3 PBR;
  mat3x3 tbn;
  uint pixelId;
  float reflCoef;
  vec4 diffuseColor;
  vec3 emissiveColor;
  bool hasHit;
};

//
struct PathTraceOutput {
  vec3 normals; float hitT;
  uvec4 indices;
};

//
PathTraceOutput pathTraceCommand(in PathTraceCommand cmd, in uint type) {
  RayData rayData = cmd.rayData;

  //
  vec3 originSeedXYZ = vec3(random(rayData.launchId.xy), random(rayData.launchId.xy), random(rayData.launchId.xy));
  PathTraceOutput outp;
  outp.hitT = 0.f;
  outp.indices = uvec4(0u);
  outp.normals = cmd.normals.xyz;
  outp.indices.w = type;

  // 
  if (type == 0) {
    rayData.direction.xyz = normalize(reflective(originSeedXYZ, rayData.direction.xyz, cmd.normals.xyz, cmd.PBR.g));;
    rayData.energy = f16vec4(metallicMult(1.f.xxx, cmd.diffuseColor.xyz, cmd.PBR.b), 1.f);
    rayData.emission = f16vec4(0.f.xxx, 1.f);
  } else 
  if (type == 1) {
    //rayData.direction.xyz = rayData.direction.xyz;
    rayData.energy = f16vec4(1.f.xxx, 1.f);//f16vec4(metallicMult(1.f.xxx, materialPix.color[MATERIAL_ALBEDO].xyz, metallicFactor), 1.f);
    rayData.emission = f16vec4(0.f.xxx, 1.f);
  } else {
    rayData.direction.xyz = normalize(randomCosineWeightedHemispherePoint(originSeedXYZ, cmd.normals));
    rayData.energy = f16vec4(1.f.xxx, 1.f);
    rayData.emission = f16vec4(0.f.xxx, 1.f);
  };

  // enforce typic indice
  outp.indices.w = type;

  //
  rayData.origin += outRayNormal(rayData.direction.xyz, cmd.tbn[2].xyz) * 0.0001f;
  rayData = pathTrace(rayData, outp.hitT, outp.normals, outp.indices);

  //
  vec4 finalColor = vec4(vec3(rayData.emission.xyz), 1.f);
  finalColor = clamp(finalColor, vec4(0.f.xxx, 1.f), vec4(16.f.xxx, 1.f));

  //
  float transpCoef = cmd.diffuseColor.a;
  float reflCoef = cmd.reflCoef;

  // 
  vec4 additional = vec4(0.f);
  if (type == 0) { additional = finalColor * vec4(reflCoef.xxx, 1.f) * (outp.hitT > 0.f ? 1.f : 0.f); };
  if (type == 1) { additional = finalColor * vec4(((1.f - reflCoef) * (1.f - transpCoef)).xxx, 1.f) * (outp.hitT > 0.f ? 1.f : 0.f); };
  if (type == 2) { additional = finalColor * vec4(((1.f - reflCoef) * transpCoef).xxx, 1.f) * (outp.hitT > 0.f ? 1.f : 0.f); };

  //
  PixelSurfaceInfoRef surfaceInfo = getPixelSurface(cmd.pixelId);
  PixelHitInfoRef hitInfo = getPixelHitInfo(cmd.pixelId, type);
  hitInfo.color += additional; hitInfo.accum = TYPE(0u);

  // avoid critical error for skyboxed, also near have more priority... also, transparency may incorrect, so doing some exception
  if (outp.hitT > 0.f && 
    (hitInfo.origin.w <= 0.f || hitInfo.origin.w >= 10000.f || 
      (
        type == 0 && outp.hitT <= hitInfo.origin.w && outp.hitT < 10000.f || 
        type == 1 && outp.hitT >= hitInfo.origin.w && outp.hitT < 10000.f || 
        type == 2
      ) && 
      hitInfo.origin.w > 0.f)
    ) {
    hitInfo.indices = outp.indices; hitInfo.actualIndices = uvec4(0u);
    hitInfo.origin = vec4(outp.hitT >= 10000.f ? vec4(0.f.xxx, 1.f) * constants.lookAtInverse : cmd.rayData.origin.xyz, outp.hitT); hitInfo.actualOrigin = vec4(0.f);
  };

  // 
  return outp;
};


// 
void retranslateHit(in uint pixelId, in uint type, in vec3 origin) {
  PixelHitInfoRef hitInfo = getPixelHitInfo(pixelId, type);
  hitInfo.indices = hitInfo.actualIndices, hitInfo.actualIndices = uvec4(0u);
  hitInfo.color = cvtRgb16Acc(hitInfo.accum), hitInfo.accum = TYPE(0u);
  hitInfo.origin = hitInfo.actualOrigin, hitInfo.origin.xyz = origin, hitInfo.actualOrigin = vec4(0.f);
};

// 
void blankHit(in PathTraceCommand cmd, in uint type) {
  PixelHitInfoRef hitInfo = getPixelHitInfo(cmd.pixelId, type);
  hitInfo.indices = hitInfo.actualIndices, hitInfo.actualIndices = uvec4(0u);
  hitInfo.color = cvtRgb16Acc(hitInfo.accum) + vec4(0.f.xxx, 1.f), hitInfo.accum = TYPE(0u);
  hitInfo.origin = hitInfo.actualOrigin, hitInfo.origin.xyz = cmd.rayData.origin.xyz, hitInfo.origin.w = 0.f, hitInfo.actualOrigin = vec4(0.f);
};

// 
void backgroundHit(in uint pixelId, in uint type, in vec3 origin) {
  PixelHitInfoRef hitInfo = getPixelHitInfo(pixelId, type);
  hitInfo.indices = uvec4(0u.xxx, 4);
  hitInfo.color = ((type == 2) ? vec4(1.f.xxxx) : vec4(0.f.xxx, 1.f)), hitInfo.accum = TYPE(0u);
  hitInfo.origin = vec4(vec4(0.f.xxx, 1.f) * constants.lookAtInverse, 10000.f), hitInfo.actualOrigin = vec4(0.f);
};

//
void blankHit(in uint pixelId, in uint type, in vec3 origin) {
  PixelHitInfoRef hitInfo = getPixelHitInfo(pixelId, type);
  hitInfo.indices = uvec4(0u.xxx, 4);
  hitInfo.color = vec4(0.f.xxx, 1.f), hitInfo.accum = TYPE(0u);
  hitInfo.origin = vec4(vec4(0.f.xxx, 1.f) * constants.lookAtInverse, 0.f), hitInfo.actualOrigin = vec4(0.f);
};


// 
void retranslateSurface(in uint pixelId) {
  PixelSurfaceInfoRef surfaceInfo = getPixelSurface(pixelId);
  surfaceInfo.indices = surfaceInfo.actualIndices, surfaceInfo.actualIndices = uvec4(0u);
  surfaceInfo.origin = surfaceInfo.actualOrigin, surfaceInfo.actualOrigin = vec3(0.f);
  surfaceInfo.normal = surfaceInfo.actualNormal, surfaceInfo.actualNormal = vec3(0.f);
  surfaceInfo.emission = cvtRgb16Acc(surfaceInfo.emissionAccum), surfaceInfo.emissionAccum = TYPE(0u);
  surfaceInfo.diffuse = cvtRgb16Acc(surfaceInfo.diffuseAccum), surfaceInfo.diffuseAccum = TYPE(0u);
};

//
void retranslateSurface(in PathTraceCommand cmd) {
  PixelSurfaceInfoRef surfaceInfo = getPixelSurface(cmd.pixelId);
  surfaceInfo.indices = uvec4(cmd.intersection.instanceId, cmd.intersection.geometryId, cmd.intersection.primitiveId, 0u);
  surfaceInfo.origin = surfaceInfo.actualOrigin, surfaceInfo.origin.xyz = cmd.rayData.origin.xyz, surfaceInfo.actualOrigin = vec3(0.f);
  surfaceInfo.normal = cmd.normals, surfaceInfo.actualNormal = vec3(0.f);
  surfaceInfo.emission = vec4(cmd.emissiveColor.xyz, 1.f), surfaceInfo.emissionAccum = TYPE(0u);
  surfaceInfo.diffuse = vec4(cmd.diffuseColor.xyz, 1.f), surfaceInfo.diffuseAccum = TYPE(0u);
};


// 
void main() {
#ifdef ENABLE_CHECKERBOARD
  const uvec2 gcoord_ = gl_GlobalInvocationID.xy;
#endif
  {
#ifdef ENABLE_CHECKERBOARD
    const bool firstPart = gcoord_.y < (extent.y/2);
    const uvec2 gcoord = firstPart ? uvec2(gcoord_.x, gcoord_.y * 2 + ((gcoord_.x&1)^(frameCounter&1))) : uvec2(gcoord_.x, (gcoord_.y - (extent.y/2)) * 2u + ((gcoord_.x&1u)^(1u-(frameCounter&1u))));
#else
    const bool firstPart = true;
    const uvec2 gcoord = gl_GlobalInvocationID.xy;
#endif

    // 
    const vec2 tCoord = vec2(gcoord)/vec2(extent);
    const uint pixelId = gcoord.x + extent.x * gcoord.y;

    //
    vec3 rayBegin = divW(vec4(vec3(tCoord, 0.f) * 2.f - 1.f, 1.f) * constants.perspectiveInverse) * constants.lookAtInverse;//fullTransform(instanceInfo, attrib.data[VERTEX_VERTICES], intersection.geometryId);
    vec3 rayEnd = divW(vec4(vec3(tCoord, 1.f) * 2.f - 1.f, 1.f) * constants.perspectiveInverse) * constants.lookAtInverse;
    vec3 rayDir = normalize(rayEnd.xyz - rayBegin.xyz);

    //
    RayData rayData;
    rayData.launchId = u16vec2(gcoord.xy);
    rayData.origin = rayBegin.xyz;
    rayData.direction = rayDir;
    rayData.energy = f16vec4(1.f.xxx, 1.f);
    rayData.emission = f16vec4(0.f.xxx, 1.f);

    //
  #ifdef USE_RASTERIZE_PASS
    IntersectionInfo intersection = rasterize(instancedData.opaqueAddressInfo, rayData, 10000.f);
  #else
    IntersectionInfo intersection = traceRaysOpaque(instancedData.opaqueAddressInfo, rayData, 10000.f);
  #endif

    // 
    InstanceInfo instanceInfo = getInstance(instancedData.opaqueAddressInfo, intersection.instanceId);
    GeometryInfo geometryInfo = getGeometry(instanceInfo, intersection.geometryId);
    GeometryExtData geometry = getGeometryData(geometryInfo, intersection.primitiveId);
    GeometryExtAttrib attrib = interpolate(geometry, intersection.barycentric);

    //
    PathTraceCommand cmd;
    cmd.pixelId = pixelId;
    cmd.intersection = intersection;
    cmd.hasHit = !all(lessThanEqual(cmd.intersection.barycentric, 0.f.xxx));
    cmd.rayData = rayData;
    cmd.rayData.origin = cmd.hasHit ? fullTransform(instanceInfo, attrib.data[VERTEX_VERTICES], intersection.geometryId).xyz : (vec4(0.f.xxx, 1.f) * constants.lookAtInverse + cmd.rayData.direction * 10000.f);
    cmd.tbn = getTBN(attrib); //cmd.rayData.origin += outRayNormal(cmd.rayData.direction.xyz, cmd.tbn[2].xyz) * 0.0001f;
    cmd.tbn[0] = fullTransformNormal(instanceInfo, cmd.tbn[0], intersection.geometryId);
    cmd.tbn[1] = fullTransformNormal(instanceInfo, cmd.tbn[1], intersection.geometryId);
    cmd.tbn[2] = fullTransformNormal(instanceInfo, cmd.tbn[2], intersection.geometryId);

    //
    const bool inner = dot(cmd.tbn[2], cmd.rayData.direction.xyz) > 0.f;

    //
    const MaterialPixelInfo materialPix = handleMaterial(getMaterialInfo(geometryInfo), attrib.data[VERTEX_TEXCOORD].xy, cmd.tbn);
    const vec4 skyColor = pow(texture(sampler2D(textures[background], samplers[0]), lcts(cmd.rayData.direction.xyz)), vec4(1.f/2.2f.xxx, 1.f));

    //
    cmd.normals = inRayNormal(cmd.rayData.direction.xyz, materialPix.color[MATERIAL_NORMAL].xyz);
    cmd.diffuseColor = toLinear(cmd.hasHit ? materialPix.color[MATERIAL_ALBEDO] : vec4(skyColor.xyz, 1.f));
    cmd.emissiveColor = toLinear(cmd.hasHit ? materialPix.color[MATERIAL_EMISSIVE] : vec4(0.f.xxx, 1.f)).xyz;
    cmd.PBR = cmd.hasHit ? materialPix.color[MATERIAL_PBR].xyz : 0.f.xxx;
    cmd.reflCoef = (cmd.PBR.b + mix(fresnel_schlick(0.f, dot(reflect(cmd.rayData.direction.xyz, cmd.normals), cmd.normals)), 0.f, cmd.PBR.g) * (1.f - cmd.PBR.b)) * (1.f - luminance(cmd.emissiveColor.xyz));

    //
    retranslateSurface(cmd);
    retranslateHit(pixelId, 0, cmd.rayData.origin);
    retranslateHit(pixelId, 1, cmd.rayData.origin);
    retranslateHit(pixelId, 2, cmd.rayData.origin);

    // 
    if (firstPart) {
      if (cmd.hasHit) {
        if (cmd.reflCoef > 0.f) { pathTraceCommand(cmd, 0); } else { blankHit(cmd, 0); };
        if (cmd.diffuseColor.a < 1.f) { pathTraceCommand(cmd, 1); } else { blankHit(cmd, 1); };
        if (luminance(cmd.diffuseColor.xyz) >= 0.001f && cmd.diffuseColor.a > 0.f) { pathTraceCommand(cmd, 2); } else { blankHit(cmd, 2); };
      } else {
        blankHit(pixelId, 0, rayData.origin);
        blankHit(pixelId, 1, rayData.origin);
        backgroundHit(pixelId, 2, rayData.origin);
      };
    };
  };
};
