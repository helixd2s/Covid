#version 460 core

//
// TODO! Planned to replace by FSR 2.0 or DLSS!!!

// 
#extension GL_GOOGLE_include_directive : require

//
#include "lib/native.glsl"
#include "lib/fresnel.glsl"
#include "lib/random.glsl"
#include "lib/sphere.glsl"
#include "lib/rasterizer.glsl"
#include "lib/reprojection.glsl"

//
layout (local_size_x = 32, local_size_y = 4, local_size_z = 1) in;

// TODO: use library or AI for fill such holes of rendering
// such as part of DLSS 2.x or FSR 2.0
vec4 readAndNeighborColor(in uint pixelId, in uint type) {
  PixelSurfaceInfoRef hitInfo = getPixelSurface(pixelId);
  TYPE center = hitInfo.accum[type];
  /*if (center.w <= 0.f) {
    center = TYPE(0.f);
    if ((pixelId + UR(deferredBuf.extent).x) < (UR(deferredBuf.extent).y * UR(deferredBuf.extent).x)) { PixelSurfaceInfoRef info = getPixelSurface(pixelId + UR(deferredBuf.extent).x); if (info.accum[type].w > 0) { center += info.accum[type]; }; };
    if ((pixelId.x%UR(deferredBuf.extent).x) < UR(deferredBuf.extent).x-1)                { PixelSurfaceInfoRef info = getPixelSurface(pixelId + 1); if (info.accum[type].w > 0) { center += info.accum[type]; }; };
    if (pixelId >= UR(deferredBuf.extent).x)                                  { PixelSurfaceInfoRef info = getPixelSurface(pixelId - UR(deferredBuf.extent).x); if (info.accum[type].w > 0) { center += info.accum[type]; }; };
    if ((pixelId.x%UR(deferredBuf.extent).x) >= 1)                            { PixelSurfaceInfoRef info = getPixelSurface(pixelId - 1); if (info.accum[type].w > 0) { center += info.accum[type]; }; };
  };*/
  return cvtRgb16Acc(center);
};

// TODO: use library or AI for fill such holes of rendering
// such as part of DLSS 2.x or FSR 2.0
vec4 readAndNeighborTex(in uint pixelId, in uint tex) {
  PixelSurfaceInfoRef hitInfo = getPixelSurface(pixelId);
  vec4 center = hitInfo.tex[tex];
  return center;
};

// TODO: use library or AI for fill such holes of rendering
// such as part of DLSS 2.x or FSR 2.0
void main() {
  const uvec2 gcoord = gl_GlobalInvocationID.xy;
  const vec2 tCoord = (vec2(gcoord) + 0.5f)/vec2(UR(deferredBuf.extent));
  const uint linearId = gcoord.x + UR(deferredBuf.extent).x * gcoord.y;
  const uint type = linearId / (UR(deferredBuf.extent).x * UR(deferredBuf.extent).y);
  const uint pixelId = linearId % (UR(deferredBuf.extent).x * UR(deferredBuf.extent).y);

  //
  const vec3 dstRayBegin = divW(vec4(vec3(tCoord, 0.f) * 2.f - 1.f, 1.f) * constants.perspectiveInverse) * constants.lookAtInverse[0];//fullTransform(instanceInfo, attrib.data[VERTEX_VERTICES], intersection.geometryId);
  const vec3 dstRayEnd = divW(vec4(vec3(tCoord, 1.f) * 2.f - 1.f, 1.f) * constants.perspectiveInverse) * constants.lookAtInverse[0];
  const vec3 dstRayDir = normalize(dstRayEnd.xyz - dstRayBegin.xyz);

  // 
  const vec4 resultRefl = readAndNeighborColor(pixelId, 0);
  const vec4 resultTransp = readAndNeighborColor(pixelId, 1);
  const vec4 resultColor = readAndNeighborColor(pixelId, 2);
  const vec4 resultEmission = readAndNeighborTex(pixelId, EMISSION_TEX);
  const vec4 resultDiffuse = readAndNeighborTex(pixelId, DIFFUSE_TEX);

  // 
  vec4 finalColor = vec4(clampCol(
    clampColW(resultTransp) * (1.f - resultDiffuse.a) + 
    clampColW(resultColor) * resultDiffuse.a + 
    //clampColW(trueMultColor(clampColW(resultColor), clampColW(resultDiffuse))) * resultDiffuse.a + 
    clampColW(resultEmission) + 
    clampColW(resultRefl)
  ).xyz, 1.f);

  //
  imageStore(imagesRgba32F[deferredBuf.images[0][0]], ivec2(gcoord), finalColor);
};
