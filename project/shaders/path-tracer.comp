#version 460 core

// 
#extension GL_GOOGLE_include_directive : require

//
#define ENABLE_CHECKERBOARD
#define USE_RASTERIZE_PASS

//
#include "lib/raytracing.glsl"
#include "lib/rasterizer.glsl"

//
layout (local_size_x = 32, local_size_y = 4, local_size_z = 1) in;

// 
void main() {
#ifdef ENABLE_CHECKERBOARD
  const uvec2 gcoord_ = gl_GlobalInvocationID.xy;
#endif
  {
#ifdef ENABLE_CHECKERBOARD
    const bool firstPart = gcoord_.y < (extent.y/2);
    const uvec2 gcoord = firstPart ? uvec2(gcoord_.x, gcoord_.y * 2 + ((gcoord_.x&1)^(frameCounter&1))) : uvec2(gcoord_.x, (gcoord_.y - (extent.y/2)) * 2u + ((gcoord_.x&1u)^(1u-(frameCounter&1u))));
#else
    const bool firstPart = true;
    const uvec2 gcoord = gl_GlobalInvocationID.xy;
#endif

    // 
    const vec2 tCoord = (vec2(gcoord)+0.5f)/vec2(extent);
    const uint pixelId = gcoord.x + extent.x * gcoord.y;

    //
    vec4 ssEye = vec4(vec3(tCoord, 0.f) * 2.f - 1.f, 1.f);
    vec3 rayBegin = divW(ssEye * constants.perspectiveInverse) * constants.lookAtInverse[0];//fullTransform(instanceInfo, attrib.data[VERTEX_VERTICES], intersection.geometryId);
    vec3 rayEnd = divW(vec4(vec3(tCoord, 1.f) * 2.f - 1.f, 1.f) * constants.perspectiveInverse) * constants.lookAtInverse[0];
    vec3 rayDir = normalize(rayEnd.xyz - rayBegin.xyz);

    //
    //PathTraceCommand cmd;
  #define cmd cmds[gl_LocalInvocationID.y][gl_LocalInvocationID.x]
    //cmd.pixelId = pixelId;
    cmd.rayData.launchId = u16vec2(gcoord.xy);
    cmd.rayData.origin = rayBegin.xyz;
    cmd.rayData.direction = rayDir;
    cmd.rayData.energy = f16vec4(1.f.xxx, 1.f);
    cmd.rayData.emission = f16vec4(0.f.xxx, 1.f);

    //
    cmd.intersection.barycentric = vec3(0.f.xxx);
    cmd.intersection.hitT = 10000.f;
    cmd.intersection.instanceId = 0u;
    cmd.intersection.geometryId = 0u;
    cmd.intersection.primitiveId = 0u;

    //
    vec4 ssLastPos = ssEye;
    cmd.intersection = rasterize(instancedData, cmd.rayData, 10000.f, ssLastPos, false);

    //
    const bool hasHit = !all(lessThanEqual(cmd.intersection.barycentric, 0.f.xxx));

    // 
    if (hasHit) {
      InstanceInfo instanceInfo = getInstance(instancedData, cmd.intersection.instanceId);
      GeometryInfo geometryInfo = getGeometry(instanceInfo, cmd.intersection.geometryId);
      GeometryExtData geometry = getGeometryData(geometryInfo, cmd.intersection.primitiveId);
      GeometryExtAttrib attrib = interpolate(geometry, cmd.intersection.barycentric);

      //
      cmd.rayData.origin = hasHit ? fullTransform(instanceInfo, attrib.data[VERTEX_VERTICES], cmd.intersection.geometryId, 0).xyz : (vec4(0.f.xxx, 1.f) * constants.lookAtInverse[0] + cmd.rayData.direction * 10000.f);
      cmd.tbn = f16mat3x3(getTBN(attrib)); //cmd.rayData.origin += outRayNormal(cmd.rayData.direction.xyz, cmd.tbn[2].xyz) * 0.0001f;
      cmd.tbn[0] = f16vec3(fullTransformNormal(instanceInfo, cmd.tbn[0], cmd.intersection.geometryId, 0));
      cmd.tbn[1] = f16vec3(fullTransformNormal(instanceInfo, cmd.tbn[1], cmd.intersection.geometryId, 0));
      cmd.tbn[2] = f16vec3(fullTransformNormal(instanceInfo, cmd.tbn[2], cmd.intersection.geometryId, 0));

      //
      const MaterialPixelInfo materialPix = handleMaterial(getMaterialInfo(geometryInfo), attrib.data[VERTEX_TEXCOORD].xy, cmd.tbn);
      const bool inner = dot(vec3(cmd.tbn[2]), cmd.rayData.direction.xyz) > 0.f;

      //
      cmd.normals = f16vec3(inRayNormal(cmd.rayData.direction.xyz, materialPix.color[MATERIAL_NORMAL].xyz));
      cmd.diffuseColor = f16vec4(toLinear(hasHit ? materialPix.color[MATERIAL_ALBEDO] : vec4(skyColor.xyz, 1.f)));
      cmd.emissiveColor = f16vec3(toLinear(hasHit ? materialPix.color[MATERIAL_EMISSIVE] : vec4(0.f.xxx, 1.f)).xyz * 4.f);

      //
      cmd.PBR = f16vec3(hasHit ? materialPix.color[MATERIAL_PBR].xyz : 0.f.xxx);
      cmd.reflCoef = (float(cmd.PBR.b) + mix(fresnel_schlick(0.f, dot(reflect(cmd.rayData.direction.xyz, vec3(cmd.normals)), vec3(cmd.normals))), 0.f, float(cmd.PBR.g)) * (1.f - float(cmd.PBR.b))) * (1.f - luminance(cmd.emissiveColor.xyz));
    } else {
      const vec4 skyColor = fromLinear(vec4(texture(sampler2D(textures[background], samplers[0]), lcts(cmd.rayData.direction.xyz)).xyz, 0.f));
      cmd.diffuseColor = f16vec4(vec4(gamma3(toLinear(skyColor.xyz)), 1.f));
      cmd.emissiveColor = f16vec3(0.f.xxx.xyz);
      cmd.rayData.origin = 0.f.xxx;
    };

    //
    retranslateSurface(cmd);
    retranslateHit(pixelId, 0, cmd.rayData.origin);
    retranslateHit(pixelId, 1, cmd.rayData.origin);
    retranslateHit(pixelId, 2, cmd.rayData.origin);

    // 
    if (hasHit) {
      pathTraceCommand(cmd, firstPart && (cmd.diffuseColor.a >= 0.001f && luminance(cmd.diffuseColor.xyz) > 0.f) ? 2 : 0);
      if (cmd.diffuseColor.a < 1.f) { pathTraceCommand(cmd, 1); } else { blankHit(cmd, 1); };
    } else {
      backgroundHit(pixelId, 0, cmd.rayData.origin, cmd.diffuseColor);
      backgroundHit(pixelId, 1, cmd.rayData.origin, cmd.diffuseColor);
      backgroundHit(pixelId, 2, cmd.rayData.origin, cmd.diffuseColor);
    };

    //
    reprojHit(pixelId, 0);
    reprojHit(pixelId, 1);
    reprojHit(pixelId, 2);

    //PixelSurfaceInfoRef surfaceInfo = getPixelSurface(pixelId);
    //for (uint i=0;i<3;i++) { surfaceInfo.accum[i] = TYPE(0u); };
  };
};
