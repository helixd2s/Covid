#version 460 core

// 
#extension GL_GOOGLE_include_directive : require

//
#include "lib/native.glsl"
#include "lib/fresnel.glsl"
#include "lib/random.glsl"
#include "lib/sphere.glsl"
#include "lib/rasterizer.glsl"

//
layout (local_size_x = 32, local_size_y = 4, local_size_z = 1) in;

//
vec4 readAndNeighborColor(in uint pixelId, in uint type) {
  PixelSurfaceInfoRef hitInfo = getPixelSurface(pixelId);
  TYPE center = hitInfo.color[type];
  if (center.w <= 0.f) {
    center = TYPE(0.f);
    if ((pixelId + extent.x) < (extent.y * extent.x)) { PixelSurfaceInfoRef info = getPixelSurface(pixelId + extent.x); if (info.color[type].w > 0) { center += info.color[type]; }; };
    if ((pixelId.x%extent.x) < extent.x-1)            { PixelSurfaceInfoRef info = getPixelSurface(pixelId + 1); if (info.color[type].w > 0) { center += info.color[type]; }; };
    if (pixelId >= extent.x)                          { PixelSurfaceInfoRef info = getPixelSurface(pixelId - extent.x); if (info.color[type].w > 0) { center += info.color[type]; }; };
    if ((pixelId.x%extent.x) >= 1)                    { PixelSurfaceInfoRef info = getPixelSurface(pixelId - 1); if (info.color[type].w > 0) { center += info.color[type]; }; };
  };
  return cvtRgb16Acc(center);
};

//
vec4 readAndNeighborTex(in uint pixelId, in uint tex) {
  PixelSurfaceInfoRef hitInfo = getPixelSurface(pixelId);
  vec4 center = hitInfo.tex[tex];
  //if (center.w <= 0.f) {
    //center = vec4(0.f);
    //if ((pixelId + extent.x) < (extent.y * extent.x)) { PixelSurfaceInfoRef info = getPixelSurface(pixelId + extent.x); center += info.tex[tex]; };
    //if ((pixelId.x%extent.x) < extent.x-1)            { PixelSurfaceInfoRef info = getPixelSurface(pixelId + 1); center += info.tex[tex]; };
    //if (pixelId >= extent.x)                          { PixelSurfaceInfoRef info = getPixelSurface(pixelId - extent.x); center += info.tex[tex]; };
    //if ((pixelId.x%extent.x) >= 1)                    { PixelSurfaceInfoRef info = getPixelSurface(pixelId - 1); center += info.tex[tex]; };
  //};
  return center;
};

// 
void main() {
  const uvec2 gcoord = gl_GlobalInvocationID.xy;
  const vec2 tCoord = vec2(gcoord)/vec2(extent);
  const uint pixelId = gcoord.x + extent.x * gcoord.y;

  //
  const vec3 dstRayBegin = divW(vec4(vec3(tCoord, 0.f) * 2.f - 1.f, 1.f) * constants.perspectiveInverse) * constants.lookAtInverse[0];//fullTransform(instanceInfo, attrib.data[VERTEX_VERTICES], intersection.geometryId);
  const vec3 dstRayEnd = divW(vec4(vec3(tCoord, 1.f) * 2.f - 1.f, 1.f) * constants.perspectiveInverse) * constants.lookAtInverse[0];
  const vec3 dstRayDir = normalize(dstRayEnd.xyz - dstRayBegin.xyz);

  // 
  const vec4 resultRefl = readAndNeighborColor(pixelId, 0);
  const vec4 resultTransp = readAndNeighborColor(pixelId, 1);
  const vec4 resultColor = readAndNeighborColor(pixelId, 2);
  const vec4 resultEmission = readAndNeighborTex(pixelId, EMISSION_TEX);
  const vec4 resultDiffuse = readAndNeighborTex(pixelId, DIFFUSE_TEX);

  // 
  const vec4 finalColor = vec4(clampCol(
    clampCol(resultTransp) * (1.f - resultDiffuse.a) + 
    clampCol(resultColor) * resultDiffuse.a + 
    //clampCol(trueMultColor(clampCol(resultColor), clampCol(resultDiffuse))) * resultDiffuse.a + 
    clampCol(resultEmission) + 
    clampCol(resultRefl)
  ).xyz, 1.f);

  // final color
  imageStore(images[swapchain.image], ivec2(gcoord.x, extent.y-1-gcoord.y), fromLinear(finalColor));

  //
  for (uint t=0;t<3;t++) {
    PixelSurfaceInfoRef surface = getPixelSurface(pixelId);

    // 
    vec4 unlimited = cvtRgb16Acc(surface.color[t]);
    vec4 average = unlimited/max(unlimited.w, 1.f);
    vec4 limited = average * min(max(unlimited.w, 1.f), 16.f);

    // 
    surface.color[t] = cvtRgb16Float(limited);
    surface.accum[t] = TYPE(0u);
    PixelHitInfoRef newHitInfo = getNewHit(pixelId, t);
    PixelHitInfoRef hitInfo = getRpjHit(pixelId, t);

    //
    hitInfo.indices = uvec4(0u);
    hitInfo.origin = vec4(0.f.xxxx);

    // re-save for reprojection
    retranslateBackHit(pixelId, t);
  };
};
