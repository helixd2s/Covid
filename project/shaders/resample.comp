#version 460 core

// 
#extension GL_GOOGLE_include_directive : require

//
#define OUTSOURCE

//
#include "lib/native.glsl"
#include "lib/fresnel.glsl"
#include "lib/random.glsl"
#include "lib/sphere.glsl"
#include "lib/rasterizer.glsl"
#include "lib/reprojection.glsl"

//
layout (local_size_x = 32, local_size_y = 12, local_size_z = 1) in;

// 
void main() {
  const uvec2 gcoord = gl_GlobalInvocationID.xy;
  const vec2 tCoord = (vec2(gcoord) + 0.5f)/vec2(extent);
  const uint linearId = gcoord.x + extent.x * gcoord.y;
  const uint type = linearId / (extent.x * extent.y);
  const uint pixelId = linearId % (extent.x * extent.y);

  //
  const vec3 srcRayBegin = divW(vec4(vec3(tCoord, 0.f) * 2.f - 1.f, 1.f) * constants.perspectiveInverse) * constants.lookAtInverse[1];//fullTransform(instanceInfo, attrib.data[VERTEX_VERTICES], intersection.geometryId);
  const vec3 srcRayEnd = divW(vec4(vec3(tCoord, 1.f) * 2.f - 1.f, 1.f) * constants.perspectiveInverse) * constants.lookAtInverse[1];
  const vec3 srcRayDir = normalize(srcRayEnd.xyz - srcRayBegin.xyz);

  //
  PixelSurfaceInfoRef surface = getPixelSurface(pixelId);
  if (surface.origin.x != 0.f || surface.origin.y != 0.f || surface.origin.z != 0.f) {
    if (type == 2) { 
      //reprojectDiffuse(pixelId, srcRayDir, 2); 
      reprojectDiffuse(pixelId, srcRayDir, type); 
    } else { 
      reproject3D(pixelId, srcRayDir, type); 
    };
  };
};
