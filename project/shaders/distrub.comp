#version 460 core

// 
#extension GL_GOOGLE_include_directive : require

//
#define OUTSOURCE

//
#include "lib/native.glsl"
#include "lib/fresnel.glsl"
#include "lib/random.glsl"
#include "lib/sphere.glsl"
#include "lib/rasterizer.glsl"
#include "lib/reprojection.glsl"
//#include "lib/atomic.glsl"

//
layout (local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

// 
void main() {
  const uint threadId = gl_GlobalInvocationID.x;
  for (uint i=threadId;i<counters[HIT_COUNTER];i+= (gl_NumWorkGroups.x*gl_WorkGroupSize.x)) {
    if (i >= counters[HIT_COUNTER]) { break; };

    //
    RayHitInfoRef hitInfo = getHitInfo(i);

    // 
    const vec4 hitPersp = vec4(vec4(hitInfo.origin.xyz, 1.f) * constants.lookAt[0], 1.f) * constants.perspective;
    const vec2 screen = (hitPersp.xy/hitPersp.w * 0.5f + 0.5f);
    const ivec2 intc = ivec2(screen * vec2(UR(deferredBuf.extent)));
    const uint id = uint(intc.x + intc.y * UR(deferredBuf.extent).x);
    const bool valid = intc.x >= 0 && intc.y >= 0 && intc.x < UR(deferredBuf.extent).x && intc.y < UR(deferredBuf.extent).y;

    //
    if (valid) {
      PixelSurfaceInfoRef surface = getPixelSurface(id);
      PixelHitInfoRef data = getNewHit(id, hitInfo.indices.w);

      //
      data.origin = hitInfo.origin;
      data.indices = hitInfo.indices;
      data.direct = hitInfo.direct;

      //
      accumulate(surface, hitInfo.indices.w, hitInfo.color);
    };
    
  };
};
