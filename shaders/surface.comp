#version 460 core

// 
#extension GL_GOOGLE_include_directive : require

//
#define ENABLE_CHECKERBOARD
#define USE_RASTERIZE_PASS

//
#include "lib/raytracing.glsl"
#include "lib/rasterizer.glsl"

//
layout (local_size_x = 32, local_size_y = 4, local_size_z = 1) in;

// 
void main() {
  const uvec2 ncoord = gl_GlobalInvocationID.xy;

  {
    const vec2 tShift = (vec2(random(ncoord), random(ncoord)) - 0.5f) * 0.5f;
    const vec2 tCoord = (vec2(ncoord)+0.5f)/vec2(deferredBuf.extent);

    // normalized coordinate system
    const ivec2 gcoord = ivec2(tCoord * UR(deferredBuf.extent));
    const uint pixelId = gcoord.x + UR(deferredBuf.extent).x * gcoord.y;

    //
    const vec4 ssEye = vec4(vec3(tCoord, 0.f) * 2.f - 1.f, 1.f);
    const vec3 rayBegin = divW(ssEye * constants.perspectiveInverse) * constants.lookAtInverse[0];//fullTransform(instanceInfo, attrib.data[VERTEX_VERTICES], intersection.geometryId);
    const vec3 rayEnd = divW(vec4(vec3(tCoord, 1.f) * 2.f - 1.f, 1.f) * constants.perspectiveInverse) * constants.lookAtInverse[0];
    const vec3 rayDir = normalize(rayEnd.xyz - rayBegin.xyz);

    //
  #define cmd cmds[gl_LocalInvocationID.y][gl_LocalInvocationID.x]
    cmd.rayData.launchId = u16vec2(gcoord.xy);
    cmd.rayData.origin = rayBegin.xyz;
    cmd.rayData.direction = rayDir;
    cmd.rayData.energy = f16vec4(1.f.xxx, 1.f);
    cmd.rayData.emission = f16vec4(0.f.xxx, 1.f);

    //
    vec4 ssLastPos = ssEye;
    cmd.intersection.barycentric = vec3(0.f.xxx);
    cmd.intersection.hitT = 10000.f;
    cmd.intersection.instanceId = 0u;
    cmd.intersection.geometryId = 0u;
    cmd.intersection.primitiveId = 0u;
    cmd.intersection = rasterizeVector(instancedData, cmd.rayData, 10000.f, ssLastPos, false);

    // 
    PixelSurfaceInfoRef surfaceInfo = getPixelSurface(pixelId);
    if (!all(lessThanEqual(cmd.intersection.barycentric, 0.f.xxx))) {
      InstanceInfo instanceInfo = getInstance(instancedData, cmd.intersection.instanceId);
      GeometryInfo geometryInfo = getGeometry(instanceInfo, cmd.intersection.geometryId);
      GeometryExtData geometry = getGeometryData(geometryInfo, cmd.intersection.primitiveId);
      GeometryExtAttrib attrib = interpolate(geometry, cmd.intersection.barycentric);

      //
      cmd.rayData.origin = fullTransform(instanceInfo, attrib.data[VERTEX_VERTICES], cmd.intersection.geometryId, 0).xyz;
      cmd.tbn = f16mat3x3(getTBN(attrib)); //cmd.rayData.origin += outRayNormal(cmd.rayData.direction.xyz, cmd.tbn[2].xyz) * 0.0001f;
      cmd.tbn[0] = f16vec3(fullTransformNormal(instanceInfo, cmd.tbn[0], cmd.intersection.geometryId, 0));
      cmd.tbn[1] = f16vec3(fullTransformNormal(instanceInfo, cmd.tbn[1], cmd.intersection.geometryId, 0));
      cmd.tbn[2] = f16vec3(fullTransformNormal(instanceInfo, cmd.tbn[2], cmd.intersection.geometryId, 0));

      //
      const MaterialPixelInfo materialPix = handleMaterial(getMaterialInfo(geometryInfo), attrib.data[VERTEX_TEXCOORD].xy, cmd.tbn);
      const bool inner = false;//dot(vec3(cmd.tbn[2]), cmd.rayData.direction.xyz) > 0.f;

      //
      cmd.normals = f16vec3(inRayNormal(cmd.rayData.direction.xyz, materialPix.color[MATERIAL_NORMAL].xyz));
      cmd.diffuseColor = f16vec4(toLinear(materialPix.color[MATERIAL_ALBEDO]));
      cmd.emissiveColor = f16vec3(toLinear(materialPix.color[MATERIAL_EMISSIVE])*2.f);
      cmd.PBR = f16vec3(materialPix.color[MATERIAL_PBR].xyz);
      cmd.reflCoef = (float(cmd.PBR.b) + mix(fresnel_schlick(0.f, dot(reflect(cmd.rayData.direction.xyz, vec3(cmd.normals)), vec3(cmd.normals))), 0.f, float(cmd.PBR.g)) * (1.f - float(cmd.PBR.b))) * (1.f - luminance(cmd.emissiveColor.xyz));
    
    } else {
      const vec4 skyColor = vec4(texture(sampler2D(textures[background], samplers[0]), lcts(cmd.rayData.direction.xyz)).xyz, 0.f);
      cmd.diffuseColor = f16vec4(vec4(skyColor.xyz, 1.f));
      cmd.emissiveColor = f16vec3(0.f.xxx.xyz);
      cmd.rayData.origin = vec4(0.f.xxx, 1.f) * constants.lookAtInverse[0];
      cmd.normals = f16vec3(vec3(0.f.xx, 1.f) * toNormalMat(constants.lookAtInverse[0]));
      cmd.PBR = f16vec3(0.f.xxx);
      cmd.reflCoef = 0.f;
      cmd.rayData.origin = vec4(0.f.xxx, 1.f) * constants.lookAtInverse[0] + cmd.rayData.direction * 10000.f;

      //
      for (uint i=0;i<3;i++) {
        surfaceInfo.flags[i] |= 1u;
        surfaceInfo.color[i] += vec4(i == 2 ? 1.f.xxx : 0.f.xxx, 1.f);
        //surfaceInfo.color[i] += vec4(i == 2 ? skyColor.xyz : 0.f.xxx, 1.f);
      };
    };

    // 
    if (pixelId < UR(deferredBuf.extent).x * UR(deferredBuf.extent).y && uint(cmd.rayData.launchId.x) < UR(deferredBuf.extent).x && uint(cmd.rayData.launchId.y) < UR(deferredBuf.extent).y) 
    { // TODO: merge to image or pixel buffers
      // most impotant thing
      surfaceInfo.tex[EMISSION_TEX] = f16vec4(cmd.emissiveColor, 1.f);
      surfaceInfo.tex[DIFFUSE_TEX] = cmd.diffuseColor;
      surfaceInfo.tex[PBR_TEX] = f16vec4(cmd.PBR, cmd.reflCoef);

      //
      imageStore(imagesRgba16F[deferredBuf.images[0][4]], ivec2(gcoord), vec4(cmd.normals * toNormalMat(constants.lookAt[0]), 1.f));
      imageStore(imagesRgba32F[deferredBuf.images[0][5]], ivec2(gcoord), vec4(cmd.rayData.origin.xyz, 1.f));

      //
      for (uint i=0;i<3;i++) {
        PixelHitInfoRef hitInfo = getNewHit(pixelId, i);
        hitInfo.origin.xyz = cmd.rayData.origin;
        hitInfo.normal.xyz = f16vec3(cmd.tbn[2]);
        hitInfo.direct.xyz = f16vec3(cmd.rayData.direction.xyz);
        hitInfo.indices[0] = uvec4(cmd.intersection.instanceId, cmd.intersection.geometryId, cmd.intersection.primitiveId, i);
      };
      
    };
  };
};
