#version 460 core

// 
#extension GL_GOOGLE_include_directive : require

//
#define ENABLE_CHECKERBOARD
#define USE_RASTERIZE_PASS

//
#include "lib/raytracing.glsl"
#include "lib/rasterizer.glsl"

//
layout (local_size_x = 32, local_size_y = 4, local_size_z = 1) in;

// 
void main() {
  const uvec2 ncoord = gl_GlobalInvocationID.xy;

  {
    const vec2 tShift = (vec2(random(ncoord), random(ncoord)) - 0.5f) * 0.5f;
    const vec2 tCoord = (vec2(ncoord)+0.5f)/vec2(deferredBuf.extent);

    // normalized coordinate system
    const ivec2 gcoord = ivec2(tCoord * UR(deferredBuf.extent));
    const uint pixelId = gcoord.x + UR(deferredBuf.extent).x * gcoord.y;

    //
    const vec4 ssEye = vec4(vec3(tCoord, 0.f) * 2.f - 1.f, 1.f);
    const vec3 rayBegin = divW(ssEye * constants.perspectiveInverse) * constants.lookAtInverse[0];//fullTransform(instanceInfo, attrib.data[VERTEX_VERTICES], intersection.geometryId);
    const vec3 rayEnd = divW(vec4(vec3(tCoord, 1.f) * 2.f - 1.f, 1.f) * constants.perspectiveInverse) * constants.lookAtInverse[0];
    const vec3 rayDir = normalize(rayEnd.xyz - rayBegin.xyz);

    //
  #define cmd cmds[gl_LocalInvocationID.y][gl_LocalInvocationID.x]
    cmd.rayData.launchId = u16vec2(gcoord.xy);
    cmd.rayData.origin = rayBegin.xyz;
    cmd.rayData.direction = rayDir;
    cmd.rayData.energy = f16vec4(1.f.xxx, 1.f);
    cmd.rayData.emission = f16vec4(0.f.xxx, 1.f);

    //
    cmd.intersection.barycentric = vec3(0.f.xxx);
    cmd.intersection.hitT = 10000.f;
    cmd.intersection.instanceId = 0u;
    cmd.intersection.geometryId = 0u;
    cmd.intersection.primitiveId = 0u;

    //
    vec4 ssLastPos = ssEye;
    cmd.intersection = rasterizeVector(instancedData, cmd.rayData, 10000.f, ssLastPos, false);

    //
    const bool hasHit = !all(lessThanEqual(cmd.intersection.barycentric, 0.f.xxx));

    // 
    vec4 debugColor = vec4(0.f.xxx, 1.f);

    // 
    if (hasHit) {
      InstanceInfo instanceInfo = getInstance(instancedData, cmd.intersection.instanceId);
      GeometryInfo geometryInfo = getGeometry(instanceInfo, cmd.intersection.geometryId);
      GeometryExtData geometry = getGeometryData(geometryInfo, cmd.intersection.primitiveId);
      GeometryExtAttrib attrib = interpolate(geometry, cmd.intersection.barycentric);

      //
      cmd.rayData.origin = hasHit ? fullTransform(instanceInfo, attrib.data[VERTEX_VERTICES], cmd.intersection.geometryId, 0).xyz : (vec4(0.f.xxx, 1.f) * constants.lookAtInverse[0] + cmd.rayData.direction * 10000.f);
      cmd.tbn = f16mat3x3(getTBN(attrib)); //cmd.rayData.origin += outRayNormal(cmd.rayData.direction.xyz, cmd.tbn[2].xyz) * 0.0001f;
      cmd.tbn[0] = f16vec3(fullTransformNormal(instanceInfo, cmd.tbn[0], cmd.intersection.geometryId, 0));
      cmd.tbn[1] = f16vec3(fullTransformNormal(instanceInfo, cmd.tbn[1], cmd.intersection.geometryId, 0));
      cmd.tbn[2] = f16vec3(fullTransformNormal(instanceInfo, cmd.tbn[2], cmd.intersection.geometryId, 0));

      //
      const MaterialPixelInfo materialPix = handleMaterial(getMaterialInfo(geometryInfo), attrib.data[VERTEX_TEXCOORD].xy, cmd.tbn);
      const bool inner = false;//dot(vec3(cmd.tbn[2]), cmd.rayData.direction.xyz) > 0.f;

      //
      cmd.normals = f16vec3(inRayNormal(cmd.rayData.direction.xyz, materialPix.color[MATERIAL_NORMAL].xyz));
      cmd.diffuseColor = f16vec4(toLinear(materialPix.color[MATERIAL_ALBEDO]));
      cmd.emissiveColor = f16vec3(toLinear(materialPix.color[MATERIAL_EMISSIVE])*2.f);

      //
      cmd.PBR = f16vec3(hasHit ? materialPix.color[MATERIAL_PBR].xyz : 0.f.xxx);
      cmd.reflCoef = (float(cmd.PBR.b) + mix(fresnel_schlick(0.f, dot(reflect(cmd.rayData.direction.xyz, vec3(cmd.normals)), vec3(cmd.normals))), 0.f, float(cmd.PBR.g)) * (1.f - float(cmd.PBR.b))) * (1.f - luminance(cmd.emissiveColor.xyz));

      //
      //debugColor = vec4(float(cmd.intersection.instanceId)/10.f, float(cmd.intersection.geometryId)/10.f, float(cmd.intersection.primitiveId)/1000.f, 1.f);
      //debugColor = vec4(cmd.intersection.barycentric.xyz, 1.f);
      //debugColor = vec4(attrib.data[VERTEX_TEXCOORD].xyz, 1.f);
      //debugColor = cmd.diffuseColor;

      // DEBUG
      //imageStore(images[swapchain.image], ivec2(cmd.rayData.launchId), vec4(attrib.data[MATERIAL_NORMAL].xyz * 0.5f + 0.5f, 1.f));
    } else {
      //const vec4 skyColor = vec4(texture(sampler2D(textures[background], samplers[0]), lcts(cmd.rayData.direction.xyz)).xyz, 0.f);
      cmd.diffuseColor = f16vec4(vec4(/*skyColor.xyz*/1.f.xxx, 1.f));
      cmd.emissiveColor = f16vec3(0.f.xxx.xyz);
      cmd.rayData.origin = vec4(0.f.xxx, 1.f) * constants.lookAtInverse[0];
      cmd.normals = f16vec3(vec3(0.f.xx, 1.f) * toNormalMat(constants.lookAtInverse[0]));
    };

    // 
    if (pixelId < UR(deferredBuf.extent).x * UR(deferredBuf.extent).y && uint(cmd.rayData.launchId.x) < UR(deferredBuf.extent).x && uint(cmd.rayData.launchId.y) < UR(deferredBuf.extent).y) 
    { // TODO: merge to image or pixel buffers
      // most impotant thing
      PixelSurfaceInfoRef surfaceInfo = getPixelSurface(pixelId);
      surfaceInfo.tex[EMISSION_TEX] = vec4(cmd.emissiveColor, 1.f);
      surfaceInfo.tex[DIFFUSE_TEX] = cmd.diffuseColor;
      surfaceInfo.normalDepth.xyz = cmd.normals*toNormalMat(constants.lookAt[0]);

      //
      for (uint i=0;i<3;i++) {
        {
          PixelHitInfoRef hitInfo = getNewHit(pixelId, i);
          hitInfo.origin.xyz = cmd.rayData.origin;
          hitInfo.normal.xyz = f16vec3(cmd.tbn[2]);
          hitInfo.direct.xyz = f16vec3(cmd.rayData.direction.xyz);
          hitInfo.indices[0] = uvec4(cmd.intersection.instanceId, cmd.intersection.geometryId, cmd.intersection.primitiveId, i);
        };
        if (!hasHit) { 
          const vec4 skyColor = vec4(texture(sampler2D(textures[background], samplers[0]), lcts(cmd.rayData.direction.xyz)).xyz, 0.f);
          surfaceInfo.flags[i] |= 1u;
          surfaceInfo.color[i] += vec4(i == 2 ? skyColor.xyz : 0.f.xxx, 1.f);
        };
        //surfaceInfo.debug[i] = TYPE(0u);
      };

      
    };
  };
};
