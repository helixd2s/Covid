#version 460 core

//
// TODO! Planned to replace by FSR 2.0 or DLSS!!!

// 
#extension GL_GOOGLE_include_directive : require

//
#include "lib/native.glsl"
#include "lib/fresnel.glsl"
#include "lib/random.glsl"
#include "lib/rasterizer.glsl"
#include "lib/reprojection.glsl"

//
layout (local_size_x = 32, local_size_y = 4, local_size_z = 1) in;

//
vec4 readColor(in ivec2 pixelId, in uint type) {
  TYPE center = TYPE(0.f);
  if (pixelId.x < UR(deferredBuf.extent).x && pixelId.y < UR(deferredBuf.extent).y && pixelId.x >= 0 && pixelId.y >= 0) {
    uint linearId = pixelId.x + pixelId.y * UR(deferredBuf.extent).x;
    PixelSurfaceInfoRef info = getPixelSurface(linearId); 
    if (info.accum[type].w > 0) { center += info.accum[type]; };
  };
  return cvtRgb16Acc(center);
};

//
/*
vec4 readDebugColor(in ivec2 pixelId, in uint type) {
  TYPE center = TYPE(0.f);
  if (pixelId.x < UR(deferredBuf.extent).x && pixelId.y < UR(deferredBuf.extent).y && pixelId.x >= 0 && pixelId.y >= 0) {
    uint linearId = pixelId.x + pixelId.y * UR(deferredBuf.extent).x;
    PixelSurfaceInfoRef info = getPixelSurface(linearId); 
    if (info.debug[type].w > 0) { center += info.debug[type]; };
  };
  return cvtRgb16Acc(center);
};*/

//
vec4 readPosition(in ivec2 pixelId, in uint type) {
  vec4 center = vec4(0.f);
  if (pixelId.x < UR(deferredBuf.extent).x && pixelId.y < UR(deferredBuf.extent).y && pixelId.x >= 0 && pixelId.y >= 0) {
    uint linearId = pixelId.x + pixelId.y * UR(deferredBuf.extent).x;
    PixelSurfaceInfoRef info = getPixelSurface(linearId);
    PixelHitInfoRef hit = getRpjHit(linearId, type);
    center = vec4(hit.origin.xyz, 1.f);
  };
  return cvtRgb16Acc(center);
};

//
vec4 readNormal(in ivec2 pixelId, in uint type) {
  vec4 center = vec4(0.f);
  if (pixelId.x < UR(deferredBuf.extent).x && pixelId.y < UR(deferredBuf.extent).y && pixelId.x >= 0 && pixelId.y >= 0) {
    uint linearId = pixelId.x + pixelId.y * UR(deferredBuf.extent).x;
    PixelSurfaceInfoRef info = getPixelSurface(linearId);
    PixelHitInfoRef hit = getRpjHit(linearId, type);
    center = vec4(hit.normal.xyz, 0.f);
  };
  return cvtRgb16Acc(center);
};

//
uvec4 readIndices(in ivec2 pixelId, in uint type) {
  uvec4 center = uvec4(0.f);
  if (pixelId.x < UR(deferredBuf.extent).x && pixelId.y < UR(deferredBuf.extent).y && pixelId.x >= 0 && pixelId.y >= 0) {
    uint linearId = pixelId.x + pixelId.y * UR(deferredBuf.extent).x;
    PixelSurfaceInfoRef info = getPixelSurface(linearId);
    PixelHitInfoRef hit = getRpjHit(linearId, type);
    center = hit.indices[0];
  };
  return center;
};


// TODO: use library or AI for fill such holes of rendering
// such as part of DLSS 2.x or FSR 2.0
vec4 readAndNeighborTex(in ivec2 pixelId, in uint tex) {
  vec4 center = vec4(0.f);
  if (pixelId.x < UR(deferredBuf.extent).x && pixelId.y < UR(deferredBuf.extent).y && pixelId.x >= 0 && pixelId.y >= 0) {
    uint linearId = pixelId.x + pixelId.y * UR(deferredBuf.extent).x;
    PixelSurfaceInfoRef info = getPixelSurface(linearId);
    center = info.tex[tex];
  };
  return center;
};

//
const ivec2 CH_MAP[4] = { ivec2(1,0),ivec2(-1,0),ivec2(0,1),ivec2(0,-1) };
const ivec2 DG_MAP[4] = { ivec2(1,1),ivec2(-1,-1),ivec2(-1,1),ivec2(1,-1) };
const ivec2 FL_MAP[8] = { ivec2(1,0),ivec2(-1,0),ivec2(0,1),ivec2(0,-1),ivec2(1,1),ivec2(-1,-1),ivec2(-1,1),ivec2(1,-1) };

//
vec4 readColorNeighbor(in ivec2 uv, in uint type) {
  vec4 center = readColor(uv, type);
  if (center.w < 1.f) {
    center = vec4(0.f.xxxx);
    for (uint i=0;i<4;i++) {
      const ivec2 offset = CH_MAP[i];
      center += readColor(uv + offset, type);
    };
  };
  return center;
};

//
vec4 readColorComp(in ivec2 pixelId) {
  const vec4 resultRefl = clampColW(readColorNeighbor(pixelId, 0));
  const vec4 resultTransp = clampColW(readColorNeighbor(pixelId, 1));
  const vec4 resultColor = clampColW(readColorNeighbor(pixelId, 2));
  const vec4 resultDiffuse = clampColW(readAndNeighborTex(pixelId, DIFFUSE_TEX));
  return (resultTransp * (1.f - resultDiffuse.a) + resultColor * resultDiffuse.a + resultRefl);
  //return clampColW(readDebugColor(pixelId, 2));
};


// TODO: use library or AI for fill such holes of rendering
// such as part of DLSS 2.x or FSR 2.0
void main() {
  const uvec2 gcoord = gl_GlobalInvocationID.xy;
  const vec2 tCoord = (vec2(gcoord) + 0.5f)/vec2(UR(deferredBuf.extent));
  const uint linearId = gcoord.x + UR(deferredBuf.extent).x * gcoord.y;
  const uint type = linearId / (UR(deferredBuf.extent).x * UR(deferredBuf.extent).y);
  const uint pixelId = linearId % (UR(deferredBuf.extent).x * UR(deferredBuf.extent).y);

  //
  const vec3 dstRayBegin = divW(vec4(vec3(tCoord, 0.f) * 2.f - 1.f, 1.f) * constants.perspectiveInverse) * constants.lookAtInverse[0];//fullTransform(instanceInfo, attrib.data[VERTEX_VERTICES], intersection.geometryId);
  const vec3 dstRayEnd = divW(vec4(vec3(tCoord, 1.f) * 2.f - 1.f, 1.f) * constants.perspectiveInverse) * constants.lookAtInverse[0];
  const vec3 dstRayDir = normalize(dstRayEnd.xyz - dstRayBegin.xyz);

  // 
  //const vec4 resultRefl = readColorWavelet(ivec2(gcoord), 0);
  //const vec4 resultTransp = readColorWavelet(ivec2(gcoord), 1);
  const vec4 resultColor = readColorComp(ivec2(gcoord));
  const vec4 resultEmission = readAndNeighborTex(ivec2(gcoord), EMISSION_TEX);
  const vec4 resultDiffuse = readAndNeighborTex(ivec2(gcoord), DIFFUSE_TEX);

  // 
  vec4 finalColor = vec4(clamp(
    resultColor + clampColW(resultEmission)
    //resultDiffuse
  , 0.f, 1.f).xyz, 1.f);

  //
  imageStore(imagesRgba32F[deferredBuf.images[0][0]], ivec2(gcoord), finalColor);
};
