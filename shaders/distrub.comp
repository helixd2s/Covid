#version 460 core

// 
#extension GL_GOOGLE_include_directive : require

//
#define OUTSOURCE

//
#include "lib/native.glsl"
#include "lib/fresnel.glsl"
#include "lib/random.glsl"
#include "lib/rasterizer.glsl"
#include "lib/reprojection.glsl"
//#include "lib/atomic.glsl"

//
layout (local_size_x = 32, local_size_y = 4, local_size_z = 1) in;

//
vec4 readColor(in ivec2 pixelId, in uint type) {
  TYPE center = TYPE(0.f);
  if (pixelId.x < UR(deferredBuf.extent).x && pixelId.y < UR(deferredBuf.extent).y && pixelId.x >= 0 && pixelId.y >= 0) {
    uint linearId = pixelId.x + pixelId.y * UR(deferredBuf.extent).x;
    PixelSurfaceInfoRef info = getPixelSurface(linearId); 
    if (info.color[type].w > 0) { center += info.color[type]; };
  };
  return cvtRgb16Acc(center);
};

//
vec4 readNormal(in ivec2 pixelId, in uint type) {
  if (pixelId.x < UR(deferredBuf.extent).x && pixelId.y < UR(deferredBuf.extent).y && pixelId.x >= 0 && pixelId.y >= 0) {
    uint linearId = pixelId.x + pixelId.y * UR(deferredBuf.extent).x;
    PixelSurfaceInfoRef info = getPixelSurface(linearId);
    return info.normalDepth;
  };
  return vec4(0.f.xxx, 1.f);
  //vec4 center = vec4(0.f);
  //if (pixelId.x < UR(deferredBuf.extent).x && pixelId.y < UR(deferredBuf.extent).y && pixelId.x >= 0 && pixelId.y >= 0) {
    //uint linearId = pixelId.x + pixelId.y * UR(deferredBuf.extent).x;
    //PixelSurfaceInfoRef info = getPixelSurface(linearId);
    //PixelHitInfoRef hit = getRpjHit(linearId, type);
    //center = vec4(hit.normal.xyz, 0.f);
  //};
  //return cvtRgb16Acc(center);
};

//
void getDenoised(in ivec2 pixelId, in uint type) {
  vec4 sum = vec4(0.0);
  float c_phi = 1.0;
  float n_phi = 0.5;

  vec4 uval = readColor(pixelId, type);//readColorNeighbor(pixelId, type);
  vec4 cval = clampColW(uval);
  vec4 nval = readNormal(pixelId, type);

  float cum_w = 0.0;
  for(int i=0; i<25; i++)
  {
      ivec2 uv = pixelId+ivec2(offset[i]);

      vec4 ctmp = clampColW(readColor(uv, type));
      vec3 t = cval.xyz - ctmp.xyz; //t /= max(t.x, max(t.y, t.z));
      float dist2 = dot(t,t);
      float c_w = min(exp(-(dist2)/c_phi), 1.0);

      vec3 ntmp = readNormal(uv, type).xyz;
      t = nval.xyz - ntmp.xyz;
      dist2 = max(dot(t,t), 0.0);
      float n_w = min(exp(-(dist2)/n_phi), 1.0);

      float weight = c_w*n_w*ctmp.w*kernel[i];
      sum += ctmp*weight;
      cum_w += weight;
  };

  //
  if (pixelId.x < UR(deferredBuf.extent).x && pixelId.y < UR(deferredBuf.extent).y && pixelId.x >= 0 && pixelId.y >= 0) {
    uint linearId = pixelId.x + pixelId.y * UR(deferredBuf.extent).x;
    PixelSurfaceInfoRef info = getPixelSurface(linearId); 
    info.denoised[type] = sum/max(cum_w, 0.0001f) * uval.w;
  };
};

// 
void main() {
  const uvec2 gcoord = gl_GlobalInvocationID.xy;
  const uint linearId = gcoord.x + UR(deferredBuf.extent).x * gcoord.y;
  const uint pixelId = linearId % (UR(deferredBuf.extent).x * UR(deferredBuf.extent).y);

  //
  uint type = linearId / (UR(deferredBuf.extent).x * UR(deferredBuf.extent).y);
  if (type < 3) {
    getDenoised(ivec2(gcoord) % ivec2(UR(deferredBuf.extent)), type);
  };
};
