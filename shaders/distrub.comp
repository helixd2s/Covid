#version 460 core

// 
#extension GL_GOOGLE_include_directive : require

//
#define OUTSOURCE

//
#include "lib/native.glsl"
#include "lib/fresnel.glsl"
#include "lib/random.glsl"
#include "lib/rasterizer.glsl"
#include "lib/reprojection.glsl"
//#include "lib/atomic.glsl"

//
layout (local_size_x = 32, local_size_y = 4, local_size_z = 1) in;

//
vec4 readColor(in ivec2 pixelId, in uint type) {
  TYPE center = TYPE(0.f);
  if (pixelId.x < UR(deferredBuf.extent).x && pixelId.y < UR(deferredBuf.extent).y && pixelId.x >= 0 && pixelId.y >= 0) {
    uint linearId = pixelId.x + pixelId.y * UR(deferredBuf.extent).x;
    PixelSurfaceInfoRef info = getPixelSurface(linearId); 
    if (info.color[type].w > 0) { center += info.color[type]; };
  };
  return cvtRgb16Acc(center);
};

//
void readColorNeighbor(in ivec2 uv, in uint type) {
  vec4 center = readColor(uv, type);
  if (center.w < 1.f) {
    center = vec4(0.f.xxxx);
    for (int i=0;i<25;i++) {
      const vec4 col = readColor(uv + ivec2(offset[i]), type);
      const vec4 clw = col / max(col.w, 1.f);
      center += clw * col.w * kernel[i];
    };
  };
  imageStore(imagesRgba16F[deferredBuf.images[0][1+type]], uv, center);
};

// 
void main() {
  const uvec2 gcoord = gl_GlobalInvocationID.xy;
  const uint linearId = gcoord.x + UR(deferredBuf.extent).x * gcoord.y;
  const uint pixelId = linearId % (UR(deferredBuf.extent).x * UR(deferredBuf.extent).y);

  //
  uint type = linearId / (UR(deferredBuf.extent).x * UR(deferredBuf.extent).y);
  if (type < 3) {
    readColorNeighbor(ivec2(gcoord) % ivec2(UR(deferredBuf.extent)), type);
  };
};
