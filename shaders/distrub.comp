#version 460 core

// 
#extension GL_GOOGLE_include_directive : require

//
#define OUTSOURCE

//
#include "lib/native.glsl"
#include "lib/fresnel.glsl"
#include "lib/random.glsl"
#include "lib/rasterizer.glsl"
#include "lib/reprojection.glsl"
//#include "lib/atomic.glsl"

//
layout (local_size_x = 32, local_size_y = 4, local_size_z = 1) in;

//
vec4 readColor(in ivec2 pixelId, in uint type) {
  TYPE center = TYPE(0.f);
  if (pixelId.x < UR(deferredBuf.extent).x && pixelId.y < UR(deferredBuf.extent).y && pixelId.x >= 0 && pixelId.y >= 0) {
    uint linearId = pixelId.x + pixelId.y * UR(deferredBuf.extent).x;
    PixelSurfaceInfoRef info = getPixelSurface(linearId); 
    if (info.color[type].w > 0) { center += info.color[type]; };
  };
  return cvtRgb16Acc(center);
};

//
vec4 readNormal(in ivec2 pixelId, in uint type) {
  if (pixelId.x < UR(deferredBuf.extent).x && pixelId.y < UR(deferredBuf.extent).y && pixelId.x >= 0 && pixelId.y >= 0) {
    uint linearId = pixelId.x + pixelId.y * UR(deferredBuf.extent).x;
    PixelSurfaceInfoRef info = getPixelSurface(linearId);
    return info.normalDepth;
  };
  return vec4(0.f.xxx, 1.f);
  //vec4 center = vec4(0.f);
  //if (pixelId.x < UR(deferredBuf.extent).x && pixelId.y < UR(deferredBuf.extent).y && pixelId.x >= 0 && pixelId.y >= 0) {
    //uint linearId = pixelId.x + pixelId.y * UR(deferredBuf.extent).x;
    //PixelSurfaceInfoRef info = getPixelSurface(linearId);
    //PixelHitInfoRef hit = getRpjHit(linearId, type);
    //center = vec4(hit.normal.xyz, 0.f);
  //};
  //return cvtRgb16Acc(center);
};



//
void readColorNeighbor(in ivec2 uv, in uint type) {
  vec4 center = readColor(uv, type);
  if (center.w < 1.f) {
    center = vec4(0.f.xxxx);
    for (int x=-1;x<=1;x++) {
      for (int y=-1;y<=1;y++) {
        center += readColor(uv + ivec2(x,y), type);
      };
    };
  };
  if (uv.x < UR(deferredBuf.extent).x && uv.y < UR(deferredBuf.extent).y && uv.x >= 0 && uv.y >= 0) {
    uint linearId = uv.x + uv.y * UR(deferredBuf.extent).x;
    PixelSurfaceInfoRef info = getPixelSurface(linearId); 
    info.denoised[type] = center;
  };
};

// 
void main() {
  const uvec2 gcoord = gl_GlobalInvocationID.xy;
  const uint linearId = gcoord.x + UR(deferredBuf.extent).x * gcoord.y;
  const uint pixelId = linearId % (UR(deferredBuf.extent).x * UR(deferredBuf.extent).y);

  //
  uint type = linearId / (UR(deferredBuf.extent).x * UR(deferredBuf.extent).y);
  if (type < 3) {
    readColorNeighbor(ivec2(gcoord) % ivec2(UR(deferredBuf.extent)), type);
  };
};
